# 组件渲染前的初始过程

初始化组件
创建组件实例
设置组件实例

初始化 props
初始化 slots
设置稳定组件实例

创建渲染上下文代理
创建 setup 函数上下文
执行 setup 函数获取结果
处理 setup 函数执行结果

完成组件实例设置
标准化模板或渲染函数
兼容 Options API

vue3 为了维护方便，把组件中不同状态的数据存储到不同的属性中
setupState ctx data props

在执行组件渲染函数时，直接访问渲染上下文 instance.ctx 中的属性，
做一层 proxy 对 instance.ctx 属性的访问和修改，代理到对 setupState ctx data props 中数据的访问和修改

get 代理中
setupState 优先级最高。 data props ctx 其次
其中比较昂贵的操作是多次调用 hasOwn 判断 key 在不在某个类型的数据中
第一次获取 key 对应的数据后，利用`accessCache[key]`去缓存数据，下一次再根据 key 查找数据时，直接通过`accessCache[key]`获取对应的值，不需要依次调用 hasOwn 去判断

set 代理中
setupState 优先级最高，setup 函数的返回数据。 data props ctx 其次

has 代理中
依次判断属性是否存在于 accessCache data

## 判断处理 setup 函数

判断是否有 setup
如果 setup 函数带参数，则创建一个 setupContext （attrs slots emit）
执行 setup 函数获取结果
处理 setup 执行结果

## 标准化模板或渲染函数

第一种是用 SFC 单文件的开发方式去开发组件，通过编写 template 模板去描述一个组件的 dom 结构（runtime-only 体积更小，运行时不用编辑，耗时更少，性能更小）
第二种是不借助编译，直接引入 vuejs，直接在组件对象 template 属性种写组件的模板（runtime-complied 古老项目的历史包裹）

两种区别在于是否注册了 compile 方法

a.compile 和组件 template 属性存在，render 方法不存在时，会在 JS 运行时进行模板编译，生成 render 函数
b.compile 和 render 方法不存在，组件 template 属性存在，由于没有 compile，用的 runtime-only 版本，会报警告，想要运行时编译得使用 runtime-complied 版本的 vuejs
c.组件既没有写 render 函数，也没有写 template 模板，此时要报一个警告，告诉用户组件缺少了 render 函数或者 template 模板
处理完以上情况，就把组件的 render 函数赋值给 instance.render，组件渲染时，运行 instance.render 函数生成组件的子树 vnode

使用 with 块运行时编译的渲染函数，渲染上下文的代理是
RuntimeCompiledPublicInstanceProxyHandlers，在之前渲染上下文代理 PublicInstanceProxyHandlers 的基础上进行的扩展

## 兼容 2.x

通过 applyOptions 方法实现
