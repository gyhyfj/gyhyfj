# 组件渲染过程

一个一般组件是一棵 DOM 树的抽象
组件是由模板、组件描述对象和数据构成，数据的变化会影响组件的变化
渲染成 DOM 的步骤：创建 vnode 渲染 vnode 生成 DOM

## 应用程序初始化

vue3 使用 createApp 函数，创建 app 并挂载在 DOM 上
在整个 app 对象创建过程中，利用闭包和函数柯里化，实现了参数保留
比如执行 app.mount 时不需要传入渲染器 render，因为在执行 createAppAPI 时候渲染器 render 参数已经被保留下来了

因为 vue 不仅仅是为 web 平台服务，它的目标是支持跨平台渲染，
createApp 函数内部的 app.mount 方法是一个标准的可跨平台的组件渲染流程，里面的代码不包含任何特定平台相关逻辑
因此假如在 web 平台使用，需要根据在 web 平台实现的需要重写 mount 方法

::: code-group

```ts [main.ts]
const app = createApp(App)
app.mount('#app')
```

```ts [createApp]
const createApp = (...args) => {
  // 创建app对象
  const app = ensureRenderer().createApp(...args)
  const { mount } = app
  // 重写mount方法
  app.mount = containerOrSelector => {
    // ...
  }
  return app
}
```

```ts [ensureRenderer]
// 延时创建渲染器，当用户只依赖响应式包时，就不创建渲染器
// 就可以通过tree-shaking移除核心渲染逻辑相关的代码
function ensureRenderer() {
  return (
    renderer ||
    (renderer = createRenderer<Node, Element | ShadowRoot>(rendererOptions))
  )
}
```

:::

## 核心渲染流程：创建 vnode 和渲染 vnode

vnode 本质是用来描述 DOM 的 JS 对象
在 vue 中可以描述不同类型的阶段，比如普通元素 vnode、组件 vnode、纯文本 vnode、注释 vnode 等
其中组件节点的 vnode 是对抽象事物的描述

vnode 的好处：
抽象：引入 vnode，可以把渲染过程抽象化，从而使组件抽象能力得到提升
跨平台：因为 patch vnode 的过程不同平台可以有自己的实现，可以基于 vnode 再做服务端渲染、weex、小程序的渲染

vnode 性能不是一定比手动操作 DOM 好：
基于 vnode 的 MVVM 框架，render to vnode 的过程中，渲染组件会有一定的 JS 耗时，特别是大组件
当我们去更新组件时，用户会感到明显卡顿
虽然 diff 算法尽可能地减少操作 DOM，但最终还是免不了操作 DOM
性能并不是 vnode 的优势

一开始用 createVNode 函数创建根 vnode，然后用 render 函数渲染创建好的 vnode，里面借助 patch 函数初始挂载或更新 DOM

对于组件 vnode ，先创建组件实例，再设置组件实例，然后设置并运行带有副作用的渲染函数 setupRenderEffect
创建组件实例：内部通过对象的方式去创建当前渲染的组件实例
设置组件实例：instance 保留了很多组件相关的数据，维护组件上下文，包括对 props、插槽及其他实例的属性的初始化处理

初始渲染做两件事：渲染组件生成 subTree、把 subTree 挂载到 container 中
先渲染组件内部整个 DOM 节点对应的 vnode，执行 renderComponentRoot 渲染生成对应的 subTree，

对于普通元素 vnode，使用 processElement 函数决定是挂载还是更新 DOM 节点

创建完 DOM 节点后，接下来判断如果有 props，用 hostPatchProp 函数给这个 DOM 节点添加相关的 class、style、event 等属性，并作相关处理

接下来对子节点的处理
如果是纯文本，在 web 环境下通过设置 DOM 元素的 textContent 属性设置文本
如果是数组，则执行 mountChildren 方法用深度优先遍历递归 patch 挂载 child （这里有对 child 作预处理的情况，编译优化）

组件 vnode 主要维护组件的定义对象，组件上各种 props。而组件本身是一个抽象节点，它自身的渲染其实是通过执行组件定义的 render 函数渲染生成的子树 vnode 来完成，然后再通过 patch 递归完成对整个组件树的渲染
