# 响应式的实现原理

响应式的本质是当数据变化后自动执行某个函数
映射到组件的实现就是，当数据变化后会自动触发组件的重新渲染

vue2 的 Object.defineProperty API 不能监听对象属性新增和删除，初始化阶段递归执行劫持带来的性能负担很大
vue3 为了解决这些缺点，使用 Proxy API 重写了响应式部分，并独立维护及发布了整个 reactivity 库

区别是劫持数据的方式用 Proxy 实现，收集的依赖由 watcher 实例变成了组件副作用渲染函数

如果用选项式 API，如果仅仅想在组件上下文中共享某个变量而不必去监测它的变化，就应在 created 钩子函数中去定义这个变量，减少性能代价
如果用组合式 API，则需要显式定义响应式数据

## reactive API

createReactiveObject 函数：

a.先判断 target 是不是数组或对象类型，如果不是则直接返回
b.如果对一个已经是响应式的对象再执行 reactive，则返回这个响应式对象（通过`target.__v_raw`属性来判断 target 是否已经一个响应式对象，如果是则直接返回响应式对象）
c.如果对同一个原始数据多次执行 reactive，则会返回相同的响应式对象（通过`target.__v_reactive`来判断 target 是否已经有一个响应式对象，如果有则返回这个响应式对象）
d.通过 canObserve 函数对 targe 对象限制（有`__v_skip`属性的对象，被冻结的对象，不在白名单内的对象）
e.通过 Proxy API 劫持 target 对象，把它变成响应式
f.给原始数据打标识`target.__v_reactive=observed`

Proxy 处理器对象 mutableHandlers：
访问对象属性触发 get 函数
设置对象属性触发 set 函数
删除对象属性触发 deleteProperty 函数
in 操作符触发 has 函数
Object.getOwnPropertyNames 触发 ownKeys 函数

依赖收集发生在数据访问阶段（get track）
get 函数最后会对计算值 res 进行判断，如果也是数组或对象，那么递归执行 reactive 把 res 变成响应式对象（因为 Proxy 劫持的是对象本身，并不能劫持子对象的变化）
get 函数最核心的部分是执行 track 函数收集依赖

派发通知发生在数据更新阶段（set trigger effect）
trigger 函数就是根据 target 和 key 从 targetMap 中找到相关的所有副作用函数遍历执行一遍

## readonly API

与 reactive API 的区别就是执行 createReactiveObject 函数时的参数 isReadonly 不同

readonlyHandlers
和 mutableHandlers 区别主要在 get set 和 deleteProperty 三个函数上

## ref API

为了方便地直接使用简单数据类型的响应式变量
用 reactive 处理对象类型
用 getter 和 setter 劫持简单数据类型
