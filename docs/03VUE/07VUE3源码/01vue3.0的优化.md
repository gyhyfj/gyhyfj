# Vue3.0 的优化

## 源码优化

对 vuejs 框架本身开发的优化
目的是让代码更易于开发和维护
源码的优化主要体现在使用 monorepo 和 TypeScript 管理和开发源码

### 更好的代码管理方式：monorepo

相比 vue2 的源码组织方式，monorepo 把里面的模块拆分到不同 package 中，
每个 package 有各自的 API、类型定义和测试
这样使得模块拆分更细化，职责划分更明确，模块之间依赖关系也更明确
开发人员也更容易阅读、理解和更改所有模块源码，提高代码可维护性

比如 reactivity 响应式库这样的 package 是可以独立于 vuejs 使用的，
这样用户如果只想使用 vue3 的响应式能力，可以单独依赖这个响应式库而不用去依赖整个 vuejs，减小引用包的体积大小

### 使用 TS，放弃 Flow

编码期间做类型检查，避免错误，利于 IDE 的类型推导

## 性能优化

### 减小源码体积

移除冷门的 feature，比如过滤器

引入 tree-shaking
依赖 ES6 模块语法的静态结构，通过编译阶段的静态分析，找到没有引入的模式并打上标记
在代码压缩时候被删除

### 数据劫持优化

当数据变化时，为了自动更新 DOM，必须劫持数据的更新
也就是说数据发生改变后能自动执行一些代码去更新 DOM

而 vue 怎么知道更新哪一片 DOM 呢？
因为在渲染 DOM 时访问了数据，我们可以对数据进行访问劫持，
这样在内部建立了依赖关系，也就知道数据对应的 DOM 有哪些了

vue2 是通过 Object.defineProperty 方法来劫持树的 getter 和 setter
使用复杂
性能差（嵌套层级比较深的对象，需要递归对每一层都劫持成响应式的数据）

vue3 使用 Proxy 做数据劫持
但 Proxy 不能监听到内部深层次的对象变化，因此 vue3 的处理方式是在 getter 中去递归响应式
这样的好处是真正访问到的内部对象才会变成响应式，而不是无脑递归

### patch 过程优化

通过在编译阶段优化编译的结果，实现运行时 patch 过程的优化

vue2 数据更新并触发重新渲染的粒度是组件级的，在单个组件中仍要遍历这个组件的整个 vnode 树，导致 vnode 性能和模板大小正相关，跟动态节点的数量无关。假如一个组件只有少量节点是动态节点，那么就会有很大的性能浪费

vue3 通过编译阶段对静态模板的分析，编译生成了 Block Tree

Block Tree 是将一个模板基于动态节点切割的嵌套区块，每个区块内部的节点结构是固定的，
每个区块只需要以一个 Array 来追踪自身包含的动态节点
借助 Block Tree，vue 将 vnode 更新性能与模板整体大小相关提升为与动态内容的数量相关

### 编译阶段的其他优化

slot 的编译优化、事件侦听函数的缓存优化、新的 diff 算法等待

## 语法优化

### 组合式 API

Options API 下，编写组件的本质就是在编写一个“包含了描述组件选项的对象”
当组件大时，一个组件有许多逻辑关注点，如果是 Options API 每个关注点都有自己的 Options，
如果需要修改一个逻辑，就需要在单个文件中不断上下切换和寻找

Composition API
同一个逻辑关注点的代码被组织到一起

### 逻辑复用方式

vue2 使用 mixins，确定是命名冲突和数据来源不清晰
因为每个 mixin 都可以定义自己的 props data，它们之间是无感的，很容易定义相同的变量导致命名冲突
对于一个组件，如果模板中使用不在当前组件中定义的变量，那么久不太容易知道这些变量是在哪定义的，这就是数据来源不清晰

vue3 的 composition API 可以很好解决这两个问题，还会有更好的类型支持，对 tree-shaking 友好，代码也更容易压缩

## 引入 RFC：使每个版本改动可控

Request For Comments 旨在为新功能进入框架体哦那个一个一致且受控的路径，避免走弯路
通过过去的 RFC 可以了解每一个 feature 被采用或废弃的前因后果

# Besides

通常 major 版本的升级会有很多 breaking change，这久意味着项目要改代码，所依赖的周边生态也需要升级

vue3 使用 ES6 的语法，Proxy 这样的 API 无法 polyfill，兼容性会有问题
