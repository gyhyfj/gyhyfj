# 父子组件传参

## 父传子 defineProps（props 传参）

父传给子，在使用组件时传参：
如果传递的是字符串类型， 不需要用 v-bind，如 `<Menu title="我是标题"></Menu>`
如果传递的是非字符串类型需要加 v-bind，如`<Menu :title="99"></Menu>`或`<Menu :title="count"></Menu>`

子接收参数：
通过`defineProps()`来接受，**无须引入，直接使用即可**

```vue
<script setup lang="ts">
type Props = {
  title?: string // 接受一个string类型的参数title
  data?: number[]
}
// 无默认值写法
// defineProps<Props>()

// 有默认值写法
let props = withDefaults(defineProps<Props>(), {
  title: '我是标题',
  data: () => [1, 2, 3], // 复杂数据类型要用函数返回值形式赋予默认值
})
</script>
```

:::tips
不论是没传这个值，还是传了个值但传的是 undefined，即使 undefined 通过了类型检查，
也都会被 withDefaults 赋予默认值
:::

或非 ts 写法：

```js
let props = defineProps({
  display: {
    type: String, // 一定要用大写字母开头来描述类型
    default: 'inline-block',
  },
  data: Array, // 一定要用大写字母开头来描述类型
})
```

在 script 中使用时候一定要用`props.display`
在 template 中使用时候加不加`props.`都可以：`isOn 或props.isOn`

:::danger
为了生成正确的运行时代码，传递给 defineProps 的泛型参数本身不可以是一个导入类型
这是因为 Vue 文件是单独编译的，编译器目前不会抓取导入的文件以分析源类型
( Nowadays 2022/11/18 )
:::

## 子传父 defineEmits（派发事件）

子组件派发一个自定义事件，来交给父组件来传值
`const emit = defineEmits(['on-click'])` 定义事件，defineEmits 的参数是事件名称的字符串数组
`emit('on-click', list, true)` 发送事件，发送事件名字符串，和一系列参数

```vue
<template>
  <div class="menu">
    <button @click="clickTap">派发给父组件</button>
  </div>
</template>

<script setup lang="ts">
import { reactive } from 'vue'
const list = reactive<number[]>([4, 5, 6])

const emit = defineEmits(['on-click']) // defineEmits 接受 自定义事件名称 的 字符串数组
const clickTap = () => {
  // 点击按钮，执行clickTap事件，将自定义事件'on-click'和参数list发送给父组件
  emit('on-click', list, true) // 传递自定义事件名，再传递要传的参数，可以发送多个参数
}
</script>
```

父组件接受子组件传递的自定义事件，并绑定处理函数
可能会接收多个不同自定义事件，分别绑定处理函数即可

```vue
<template>
  <!-- 将子组件传递的事件绑定事件处理函数 -->
  <Menu @on-click="getList"></Menu>
</template>

<script setup lang="ts">
import Menu from './Menu/index.vue'
import { reactive } from 'vue'

/* 事件处理函数，形参数量就是子组件发送来的参数数量，接受的就是子组件一并发过来的参数 */
const getList = (list: number[], flag: boolean) => {
  console.log(list, flag)
}
</script>
```

## 子组件暴露属性 defineExpose

使用 `<script setup>` 的组件是默认关闭的——即通过模板 ref 或者 $parent 链获取到的组件的公开实例，不会暴露任何在 `<script setup>` 中声明的绑定
通过 defineExpose 编译器宏来显式指定在 `<script setup>` 组件中要暴露出去的 property

```vue
<script setup>
import { ref } from 'vue'

const a = 1
const b = ref(2)

defineExpose({
  a,
  b,
})
</script>
```

当父组件通过模板 ref 的方式获取到当前组件的实例，获取到的实例会像这样`{ a: number, b: number }`

## vue 的属性赋值

不带冒号，后面被认作是字符串 `title="标题"`
带冒号，后面才会被认为是变量，或数值，或布尔值 `:isShow="true"` `:width="30"`
带冒号的本质就是 v-bind 指令的缩写
类似的，v-model 这样的指令不需要冒号，后面的都被认为是变量 `v-model="isShow"`
