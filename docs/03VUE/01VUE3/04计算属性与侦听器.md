# 计算属性与侦听器

## computed

omputed() 方法期望接收一个 getter 函数，返回值为一个计算属性 ref，
在 script 中需要通过`.value`来访问计算结果，计算属性 ref 也会在模板中自动解包。

Vue 的计算属性会自动追踪响应式依赖。

```vue
<script lang="ts" setup>
import { ref, computed } from 'vue'

let firstName = ref('')
let lastName = ref('')
const name = computed(() => firstName.value + ' ' + lastName.value)
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
  <br />
  {{ name }}
</template>
```

计算属性也可以通过同时提供 getter 和 setter 来创建
计算属性默认仅能通过计算函数得出结果。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：

```vue
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    ;[firstName.value, lastName.value] = newValue.split(' ')
  },
})
</script>
```

现在当你再运行 fullName.value = 'John Doe' 时，setter 会被调用而 firstName 和 lastName 会随之更新。

注意：计算函数不应有副作用，不要在计算函数中做异步请求或者更改 DOM。
注意：避免直接修改计算属性值，从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”。

## watch

侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数

```ts
// 侦听单个来源
function watch<T>(
  source: WatchSource<T>,
  callback: WatchCallback<T>,
  options?: WatchOptions
): StopHandle

// 侦听多个来源
function watch<T>(
  sources: WatchSource<T>[],
  callback: WatchCallback<T[]>,
  options?: WatchOptions
): StopHandle

type WatchCallback<T> = (
  value: T,
  oldValue: T,
  onCleanup: (cleanupFn: () => void) => void
) => void

type WatchSource<T> =
  | Ref<T> // ref
  | (() => T) // getter
  | T extends object
  ? T
  : never // 响应式对象

interface WatchOptions extends WatchEffectOptions {
  immediate?: boolean // 默认：false
  deep?: boolean // 默认：false
  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'
  onTrack?: (event: DebuggerEvent) => void
  onTrigger?: (event: DebuggerEvent) => void
}
```

例子：
a. 侦听简单数据类型：用 ref 包裹成响应式对象（不包裹是**不能**作为参数传入 watch API 的）

```vue
<script lang="ts" setup>
import { ref, watch } from 'vue'
let name = ref('')
watch(
  name,
  (newVal, oldVal) => {
    // newVal和oldVal自动解包，不需要加`.value`
    console.log(newVal)
    console.log(oldVal)
  },
  { immediate: true } // 可选参数
)
</script>

<template>
  <input type="text" v-model="name" />
</template>
```

b. 侦听复杂数据类型，但用的仍是 ref 包裹

```vue
<script lang="ts" setup>
import { ref, watch } from 'vue'
let name = ref({
  firstName: '',
  lastName: '',
})
watch(
  name,
  (newVal, oldVal) => {
    console.log(newVal)
    console.log(oldVal)
  },
  { immediate: true, deep: true } // 需要加deep:true才能侦听到属性值的变化
)
</script>

<template>
  <input type="text" v-model="name.firstName" />
  <input type="text" v-model="name.lastName" />
</template>
```

c. 侦听复杂数据类型，但用的仍是 reactive 包裹

```vue
<script lang="ts" setup>
import { reactive, watch } from 'vue'
let name = reactive({
  firstName: '',
  lastName: '',
})
watch(
  name,
  (newVal, oldVal) => {
    console.log(newVal)
    console.log(oldVal)
  },
  { immediate: true } // reactive包裹自动实现深度侦听，不需要加deep:true
)
</script>

<template>
  <input type="text" v-model="name.firstName" />
  <input type="text" v-model="name.lastName" />
</template>
```

d. 侦听复杂数据类型，如对象，但只侦听对象的某一个属性
传入 watch API 的第一个参数采用回调函数返回值的写法传入一个 getter 函数，

如果是 ref 包裹，写作` () => name.value.firstName`。如果是 reactive 包裹，写作` () => name.firstName`

```ts
<script lang="ts" setup>
/* 使用ref包裹 */
// import { ref, watch } from 'vue'
// let name = ref({
//   firstName: '',
//   lastName: '',
// })
// watch(
//   () => name.value.firstName,
//   (newVal, oldVal) => {
//     console.log(newVal)
//     console.log(oldVal)
//   },
//   { immediate: true, deep: true }
// )

/* 使用reactive包裹 */
import { reactive, watch } from 'vue'
let name = reactive({
  firstName: '',
  lastName: '',
})
watch(
  () => name.firstName,
  (newVal, oldVal) => {
    console.log(newVal)
    console.log(oldVal)
  },
  { immediate: true, deep: true }
)
</script>

<template>
  <input type="text" v-model="name.firstName" />
  <input type="text" v-model="name.lastName" />
</template>
```

f. 侦听 props
props 的表现与 reactive 包裹自动实现深度侦听，// TODO: 可能底层就是 reactive
侦听 props 的某个属性，也要写成返回某个属性的回调函数形式 `()=>props.submitted`
直接给 watch 传入 props，会自动深度侦听 props 内部所有成员

::: warning

1. 传入 watch 的第二个参数，即回调函数，它的形参不可以是 new old，因为 new 是 js 的保留字
2. vscode 写 vue 文件，使用 watch 时候，IDE 可能会自动 from fs 引入 watch，而不是 vue，有时候会注意不到而遇到奇怪的报错

:::

## watchEffect

立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。
但有可能会收集过多依赖导致反复执行操作，比如追踪到 store 对象，但操作会更新 store

第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。
第二个参数是一个可选的选项，可以用来**调整副作用的刷新时机**或**调试作用的依赖**。
返回值是一个用来停止该副作用的函数。

a. 自动检测依赖

```vue
<script lang="ts" setup>
import { ref, watchEffect } from 'vue'

let firstName = ref<string>('')
let lastName = ref<string>('')
watchEffect(() => {
  console.log(firstName.value)
  console.log(lastName.value)
})
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
</template>
```

b. 自动实现深度侦听
但是这里的“自动”，只对收集到成员依赖起作用

下面例子里 watchEffect 如果只是`console.log(name)`，则不会在其内部成员变化时候 trigger watchEffect
下面例子里 watchEffect 如果只是`console.log(name.value.firstName)`，则不会在 lastName 变化时候 trigger watchEffect

如果侦听的是一个数组，那么同样在 arr 变化时候`console.log(arr)`不会触发侦听器，但如果是侦听其成员，如`console.log(arr.length)`或`console.log(arr[3])`时候，如果这个成员改变，是会触发侦听的

```vue
<script lang="ts" setup>
import { ref, watchEffect } from 'vue'
let name = ref({
  firstName: '',
  lastName: '',
})
watchEffect(() => {
  console.log(name.value.firstName)
  console.log(name.value.lastName)
})
</script>

<template>
  <input type="text" v-model="name.firstName" />
  <input type="text" v-model="name.lastName" />
</template>
```

c. 副作用函数的参数，也是一个函数，要做的事定义在副作用函数体内，接受一个回调函数，在副作用函数其他语句执行前执行。
可以做一些事情，比如防抖，比如清除接口 // TODO

```vue
<script lang="ts" setup>
import { ref, watchEffect } from 'vue'

let firstName = ref<string>('')
let lastName = ref<string>('')
watchEffect(onCleanup => {
  console.log(firstName.value)
  console.log(lastName.value)
  /**
   * 副作用函数的参数，也是函数
   * 函数定义在这里，参数是一个回调函数
   * 这个回调函数的执行会在副作用函数其他语句之前
   */
  onCleanup(() => {
    console.log('before')
  })
})
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
</template>
```

d. watchEffect 的返回值，是一个停止侦听的**函数**

```ts
const stop = watchEffect(() => {})

// 当不再需要此侦听器时:
stop()
```

e. watchEffet 的配置选项
例如，通过添加配置 `{flush："post"}` 可以在 DOM 更新后运行副作用

```vue
<script lang="ts" setup>
import { ref, watchEffect } from 'vue'

let name = ref<string>('')
// let ipt: HTMLInputElement = document.querySelector('#ipt') as HTMLInputElement
// 如果在 watchEffect 外面拿 DOM 元素，那么 watchEffect 中怎么打印都是 null
watchEffect(
  onCleanup => {
    console.log(name.value)
    let ipt: HTMLInputElement = document.querySelector(
      '#ipt'
    ) as HTMLInputElement
    console.log('ipt:', ipt)
    onCleanup(() => {
      console.log('before')
    })
  },
  {
    flush: 'post',
  }
)
</script>

<template>
  <input id="ipt" type="text" v-model="name" />
</template>
```

::: warning
watchEffect 会自动收集依赖，如果收集到的依赖发生时间顺序上的多次变化（比如一个响应值变化导致 trigger watchEffect 改变另一个值），只会 trigger 一次 watchEffect

如果想侦听某个响应式的值，来改变另一个值，可以在传入的回调的第一行写上需要监听的值，如`a.value`
用 watchEffect 可能会出现业务逻辑的 bug，因为我们希望的是只有某个值变化时候，才改变目标的值，但 watchEffect 会收集所有依赖包括目标值， vue 文件的其他无关逻辑可能会设置对收集到依赖的改变，同样 trigger watchEffect，造成对目标值的二次改变

watchEffect 仅会在其同步执行期间，才追踪依赖。在使用异步回调时，只有在第一个 await 正常工作前访问到的属性才会被追踪。
:::

```ts
watchEffect(async () => {
  await b.value++ // a.value变化不会trigger侦听，即a.value不被收集依赖
  a.value
})

watchEffect(async () => {
  a.value // a.value会被收集依赖
  await b.value++
})

watchEffect(async () => {
  await a.value // a.value会被收集依赖，await语句后的不再被收集依赖
  await b.value++
})
```

侦听器执行防抖、节流函数：

```ts
let addB = () => {
  b.value++
}
addB = debounce(addB, 2000)

watchEffect(() => {
  a.value
  addB()
  // debounce(addB, 2000)() // 不可以
  // 防抖函数必须定义在外面，不可以写在里面，因为写在里面，每次触发侦听器都会重新生成一个新的防抖函数
})

// 或：
watch(a, () => {
  addB()
  // debounce(addB, 2000)() // 不可以
})

// 或：
watch(a, addB)

// 或：
watch(a, debounce(addB, 2000))
```

## 停止侦听器

在 `setup()` 或 `<script setup>` 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。
如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，你必须手动停止它，以防内存泄漏。

## 计算属性与侦听器

计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。
