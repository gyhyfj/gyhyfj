# 环境变量

环境变量是环境上的变量，可以为不同模式的开发和生产环境配置不同环境变量

环境变量通常可以通过 `process.env` 获取， vite 通过对象 `import.meta.env` 暴露这些环境变量

## 默认情况下

npm run build 时，运行模式是 production
`process.env.NODE_ENV` 和 `import.meta.env.MODE` 是 production，它会自动加载.env.production 中的环境变量

npm run dev 时，运行模式是 development
`process.env.NODE_ENV` 和 `import.meta.env.MODE` 是 development，它会自动加载.env.development 中的环境变量

如果通过 --mode 后面跟 production 或 development 进行指定，`process.env.NODE_ENV` 不会改变，但 `import.meta.env.MODE` 会改变

## 改变模式

--mode 后跟模式名字符串，这些模式可以是自定义的模式
配置后可以从 `import.meta.env.MODE` 读到配置的值

## .env 文件

vite 使用 dotenv 从环境目录中加载额外的环境变量
指定模式后，在根目录创建的对应模式名的 .env 文件会被读取

```bash
.env                # 所有情况下都会加载
.env.local          # 所有情况下都会加载，但会被 git 忽略
.env.[mode]         # 只在指定模式下加载
.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略
```

优先级：
带有指定模式的.env 文件优先级比默认模式的.env 文件优先级高
Vite 执行时已经存在的环境变量有最高的优先级，不会被.env 类文件覆盖。
所谓执行时已存在的变量，就是指命令行调用 vite 前，用等号赋值的变量，如
`VITE_SOME_KEY=123 vite build`

加载后：
加载后会挂在 `process.env` 和 `import.meta.env` 上
只有以`VITE_`为前缀的变量才会暴露给客户端（经过 vite 处理的代码）

```bash
VITE_SOME_KEY=123
```

## cross-env

使用原因：windows 不支持 `NODE_ENV=development` 的设置方式
cross-env 可以支持跨平台使用这样的方式配置环境变量

用法是：`cross-env 变量名=变量值 要运行的命令`
和.env 文件一样，都是挂载环境变量，只是不写在.env 文件里，而是直接写在命令行中，可用可不用

## 在哪里能访问到这些环境变量

cross-env 在命令行指定的变量：
vite.config.ts 和 ejs 中可以通过 process.env 拿到全部变量，可以通过 mode.env 拿到暴露的环境变量，src 目录中可以通过 import.meta.env 拿到暴露的环境变量，不可以通过 process.env 拿到任何挂载的变量

.env 文件挂载的环境变量：
vite.config.ts 和 ejs 中不能通过 process.env 拿到任何变量，但可以通过 mode.env 拿到暴露的环境变量，src 目录中可以通过 import.meta.env 拿到暴露的环境变量，不可以通过 process.env 拿到任何挂载的变量

process.env 上没有.env 文件写的变量，但有 cross-env 在命令行指定的变量，它挂载的变量能且只能在客户端外被访问到，无论有没有`VITE_`开头
process.env.NODE_ENV 这样已有的变量，无法通过任何方式覆写

import.meta.env 上的变量只能在 src 目录访问到，但有例外，就是 vite.config.ts 通过 mode.env 访问到，再通过 vite-ejs-plugin 插件传递给 html 的 ejs

```ts
// vite-ejs-plugin 可以在 vite.config.ts 不借助 loadEnv 函数 直接拿到全部暴露给客户端的环境变量，再传递给 html 的 ejs
import { ViteEjsPlugin } from 'vite-plugin-ejs'

export default () => {
  return defineConfig({
    plugins: [
      // config.env 等同于暴露给客户端的import.meta.env
      ViteEjsPlugin(config => ({
        ISPROD: config.env.VITE_API_MODE === 'production',
        ISEN: config.env.VITE_ISZH === 'false',
      })),
    ],
  })
}
```

最近的实战经验：
可以只用.env 挂载环境变量，不一定需要 cross-env
用--mode 指定各种 scripts 命令需要的环境变量，创造各种 dev 和 build 环境，
在 src 目录和 ejs 中通过 import.meta.env 或 mode.env 访问暴露的环境变量

process.env.NODE_ENV 只用于区分是否是 run build，可以用来配置 esbuild 等
process.env 上框架赋予的暴露给客户端的变量也可以用，比如 uni 项目中的 process.env.UNI_PLATFORM

## TS 类型提示

可以在.d.ts 文件中修改接口类型

```ts
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string
  // 更多环境变量...
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
```

## extra

如果不是 uniapp
在 vite.config.ts 中打印
process.env.NODE_ENV 无论是在 defineConfig 内还是 defineConfig 外都是 undefined

<!-- 仅当 “--module” 选项为 “es2020”、“es2022”、“esnext”、“system”、“node16” 或 “nodenext” 时，才允许使用 “import.meta” 元属性。 -->

在 vite.config.ts 中打印
import.meta 无论是在 defineConfig 内还是 defineConfig 外都是 空对象
