# 全局组件、局部组件、递归组件

## 全局组件

我们可以使用 `app.component()` 方法，让组件在当前 Vue 应用中全局可用

```ts
// main.ts
import { createApp } from 'vue'
import App from './App.vue'
import Card from './components/Card/index.vue'

createApp(App).component('Card', Card).mount('#app')
```

`app.component()` 方法可以被链式调用

```ts
const app = createApp(App)
app
  .component('ComponentA', ComponentA)
  .component('ComponentB', ComponentB)
  .component('ComponentC', ComponentC)
  .mount('#app')
```

全局组件的缺点：

1. 无法 tree-shaking
2. 依赖关系不明确，这可能会影响未来长期的可维护性，类似于使用过多的全局变量

## 局部组件

在 script setup 语法糖中 import 后即可直接使用

## 递归组件

第一种实现方式：
父组件调用子组件并传参：

```vue
// App.vue

<script lang="ts" setup>
import { reactive } from 'vue'
import Tree from './components/Tree/index.vue'

type TreeList = {
  name: string
  icon?: string
  children?: TreeList[] | []
}

const data = reactive<TreeList[]>([
  {
    name: 'no.1',
    children: [
      {
        name: 'no.1-1',
        children: [
          {
            name: 'no.1-1-1',
          },
        ],
      },
    ],
  },
  {
    name: 'no.2',
    children: [{ name: 'no.2-1' }],
  },
  {
    name: 'no.3',
  },
])
</script>

<template><Tree :data="data" /></template>
```

子组件引用自身组件，用 v-for 循环调用自身传参，用 v-if 语句结束递归

```vue
// components/Tree/index.vue

<script setup lang="ts">
import Tree from './index.vue' // 引入自身
type TreeList = {
  name: string
  icon?: string
  children?: TreeList[] | []
}
type Props = {
  data?: TreeList[]
}
defineProps<Props>()
</script>

<template>
  <div v-for="(item, index) in data" :key="index" style="padding-left: 10px">
    {{ item.name }}

    <!-- v-if作为递归的结束条件 -->
    <Tree :data="item.children" v-if="item?.children?.length" />
  </div>
</template>
```

第二种实现方式：
与第一种原理相同，都是子组件递归调用自身
但是不 import 自身，而是另写一个 script 标签，导出一个 name 属性，然后递归调用自身

```vue
<script lang="ts" setup>
// import Tree from './index.vue' // 引入自身

type TreeList = {
  name: string
  icon?: string
  children?: TreeList[] | []
}

type Props = {
  data?: TreeList[]
}
defineProps<Props>()
</script>

<script lang="ts">
export default {
  name: 'Tree',
}
</script>

<template>
  <div v-for="(item, index) in data" :key="index" style="padding-left: 10px">
    {{ item.name }}

    <!-- v-if作为递归的结束条件 -->
    <Tree :data="item.children" v-if="item?.children?.length" />
  </div>
</template>
```

## 动态组件

在 vue3 setup 语法糖中，不能用`:is="字符串变量"`来实现动态组件，必须用`:is="引入的组件实例"`

```vue
<script lang="ts" setup>
import A from './A.vue'
import B from './B.vue'
</script>

<template>
  <component :is="A"></component>
</template>

<style lang="less" scoped></style>
```

切换动态组件：

```vue
<script lang="ts" setup>
import { reactive, markRaw } from 'vue'
import A from './A.vue'
import B from './B.vue'

type Tabs = {
  name: string
  comName: any
}
type Com = Pick<Tabs, 'comName'> // type Com={comName:amy} 仍是一个对象，只是对象里只有comName这个属性

const data = reactive<Tabs[]>([
  { name: 'A', comName: markRaw(A) }, // 使用markRaw包裹组件实例，给实例添加`__v_skip:true`这个属性，跳过Proxy的代理，减少性能开支
  { name: 'B', comName: markRaw(B) },
])
let current = reactive<Com>({
  comName: data[0].comName,
})

function change(item: Tabs): void {
  current.comName = item.comName
}
</script>

<template>
  <div class="tab">
    <button v-for="item in data" :key="item.name" @click="change(item)">
      {{ item.name }}
    </button>
  </div>
  <component :is="current.comName"></component>
</template>
```
