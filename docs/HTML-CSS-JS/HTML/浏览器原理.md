# 浏览器原理

## 浏览器渲染

浏览器渲染过程

1. 首先解析文档，构建 DOM 树
2. 解析 CSS，构建 CSSOM 规则树
3. DOM 树和 CSSOM 树结合构建 Render 渲染树，不可见的 DOM 元素不会被插入渲染树
4. 布局 Render 树每个节点，当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会**根据渲染树来进行布局**（也可以叫做**回流**、**重排**）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
5. 绘制 Render 树，布局阶段结束后是**绘制**阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上

**回流一定重绘，重绘不一定回流。**

引起重流的操作：

1. 页面首次渲染
2. 浏览器窗口大小发生变化
3. 元素的内容发生变化
4. 元素的尺寸或者位置发生变化
5. 元素的字体大小发生变化
6. 查询某些属性或者调用某些方法（获取 DOM 的属性，如 offsetTop，导致重新计算，就会重排）

减少回流和重绘的方式：

1. 如果需要设置动画效果，最好使用 absolute 或者 fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。
2. 避免频繁操作样式和 DOM
3. 可以先为元素设置为不可见：display: none，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。
4. 浏览器自己也会用渲染队列的方式进行优化，通过批量处理让多次的回流、重绘变成一次回流重绘。
5. 尽量不要访问 offsetTop 这样的属性值，获取 offsetTop 的值是需要浏览器即时计算的，这时浏览器会对页面布局进行计算，所以会触发回流

```ts
// https://googlechrome.github.io/devtools-samples/jank/
// 源码当中第71行是造成性能损失的原因。第85行是优化后的写法，使用pos这个变量替代了对offsetTop的访问
// 即const pos = parseInt(m.style.top.slice(0, m.style.top.indexOf('px')))
```

CSS 如何阻塞文档解析：
遇到脚本执行需要请求样式信息时，浏览器只好延迟 JavaScript 脚本执行和文档的解析，直至浏览器完成 CSSOM 的下载和构建。

什么情况会阻塞渲染：
所谓阻塞渲染就是让渲染树生成的慢，html css js 加载、解析、执行都会阻塞渲染，尤其是 js 的加载和执行

## 浏览器组成

常见浏览器内核：

1. IE: Trident
2. Chrome: Blink （blink 内置的 JS 引擎是 V8 引擎）
3. Safari: Webkit
4. Firefox: Gecko

浏览器内核主要分成两部分：

1. 渲染引擎
2. JS 引擎（解析 JS）（blink 内置的 JS 引擎是 V8 引擎）

## 浏览器本地存储

cookie localStorage sessionStorage IndexedDB（存储大量数据时使用，⽤键值对进⾏储存，可以进⾏快速读取操作，类似 NoSQL 数据库）
它们的区别。
使用场景：
cookie:
最常见的使用场景就是 Cookie 和 session 结合使用，我们将 sessionId 存储到 Cookie 中，每次发请求都会携带这个 sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。
localStorage:
将换肤的信息、token 等存储在本地的 LocalStorage 中
sessionStorage:
由于 SessionStorage 具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。

## 浏览器缓存

浏览器发起请求->是否有缓存->是否过期
● 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；
● 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持 HTTP1.1，则使用 expires 头判断是否过期；
● 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；
