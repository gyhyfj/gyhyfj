# Module

在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器
ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案

ESModule 和 CommonJS 的区别是：
CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
CommonJS 模块的 require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。

## 编译时加载与运行时加载

ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西

CommonJS 是整体加载模块，生成一个 module.exports 对象，该对象只有在脚本运行完才会生成，然后从这个对象上读取属性或方法，这种加载叫做运行时加载，完全无法在编译时做静态优化
ES6 是通过 export 命令显式指定输出的代码，再通过 import 命令输入，不加载不需要的内容，可以在编译时完成加载

## export import

export 语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值
这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新

import 命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。
但是，如果引入的是一个对象，改写它的属性是允许的，但不推荐

import 命令具有提升效果，会提升到整个模块的头部，首先执行

import 是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构

import 语句会执行所加载的模块，因此有`import xxx`的语法。如果多次重复执行同一句 import 语句，那么只会执行一次

export default 命令其实只是输出一个叫做 default 的变量，所以它后面不能跟变量声明语句

## 跨模块常量

const 声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用 `export const a = 1`

## import()

动态加载指定的模块 返回 Promise 对象
可以用在 if 语句中或回调函数中

## import.meta

import.meta 只能在模块内部使用, 这个属性返回一个对象，该对象的各种属性就是当前运行的脚本的元信息。具体包含哪些属性，标准没有规定，由各个运行环境自行决定。

## 加载规则

浏览器加载 ES6 模块，也使用`<script>`标签，但是要加入 type="module"属性
浏览器对于带有 type="module"的`<script>`，都是异步加载, 等同于开启了 defer
如果网页有多个`<script type="module">`，它们会按照在页面出现的顺序依次执行
