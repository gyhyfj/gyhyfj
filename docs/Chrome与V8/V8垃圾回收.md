# V8 垃圾回收

JS 垃圾回收机制的原理是: 定期找出那些不再用到的内存 (变量) , 然后释放其内存

只能定期执行而无法实时做到, 因为开销过大

## GC 算法

常见有 标记清除算法 引用计数算法

### 标记清除算法

此算法分为 标记 和 清除 两个阶段, 标记阶段为所有活动对象做上标记, 清除阶段把没有标记 (也就是非活动) 的对象销毁

标记的方法很多
标记的策略是:

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记, 假设内存中所有对象都是垃圾, 全标记为 0
- 然后从各个根对象开始遍历, 把不是垃圾的节点改成 1
- 清理所有标记为 0 的垃圾, 销毁并回收它们所占用的内存空间
- 最后, 把所有内存中对象标记修改为 0, 等待下一轮垃圾回收

标记清除算法的优点只有一个, 那就是实现比较简单
标记清除算法有两个很大的缺点: 内存碎片化, 分配速度慢

- 清除之后, 剩余的对象内存位置是不变的, 也会导致空闲内存空间是不连续的, 出现了 内存碎片
- 新建对象分配内存时, 需要对空闲内存列表进行一次单项遍历, 找到足够尺寸的空间才能为其分配内存

所以通过 标记整理 算法解决这个问题
标记阶段和标记清除算法相同, 标记结束后, 标记整理算法会将活着的对象向内存的一端移动, 最后清理掉边界的内存

### 引用计数算法

这其实是早先的一种垃圾回收算法
它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`, 如果没有了, 对象将被垃圾回收机制回收
目前很少使用这种算法了, 因为它的问题很多

循环引用时, 变量的引用计数会无法归 0 导致内存泄漏

引用计数算法优点是可以立即回收, 而不需要定期执行 GC 导致暂停 JS 运行中的线程, 也不需要遍历
缺点是无法解决循环引用无法回收的问题, 以及计数器需要占很大位置, 因为没有办法知道被引用的数量上限

## V8 对 GC 的优化

### 分代式垃圾回收

因为 GC 每次回收时候都要检查内存中的所有对象,
这样对一些大、老、存活时间长的对象和新、小、存活时间短的对象的检查频率一样, 因为前者不需要频繁清理, 后者需要频繁清理

V8 的策略是将堆内存分为新生代和老生代两区域, 采用不同的垃圾回收器进行回收

#### 新生代

新生代容量比较小, 通常只有 1-8M
使用 Scavenge 算法进行垃圾回收, 而 Scavenge 算法又基于 Cheney 算法

Cheney 算法将新生代内存分为使用区和空闲区
新加入的对象会存放到使用区, 当使用区快被写满时候就执行一次 GC
标记阶段, 垃圾回收器会对使用区的活动对象做标记, 标记完成后将它们复制到空闲区并排序,
清理阶段, 垃圾回收器将非活动对象占用的空间清理掉, 最后进行角色互换, 把原来的使用区变成空闲区, 把原理的空闲区变成使用区

当一个对象经过多次复制后仍然存活, 就被认为是生命周期比较长的对象, 随后会被移动到老生代
还有一种情况是, 假如一个对象到空闲区时, 空闲区空间占用超过了 25, 那么这个对象会被直接晋升到老生代空间, 这是因为完成回收后空闲区要反转成使用区继续进行对象内存的分配, 如果占比过大, 会影响后续使用

#### 老生代

老生代就是通过常规的标记清除进行 GC, 并通过标记整理解决内存碎片化问题

### 并行回收

进行垃圾回收时会阻塞 JS 脚本的执行, 造成全停顿 (Stop-The-World)

并行回收指的是 垃圾回收器开启多个线程, 同时执行垃圾回收工作
对于新生代垃圾回收器能够有很好的优化

### 增量标记与懒性清理

对于老生代来说, 它的内部存放的都是一些比较大的对象, 对于这些大的对象 GC 时哪怕我们使用并行策略依然可能会消耗大量时间

V8 对老生代进行增量标记

增量就是将一次 GC 标记的过程, 分成了很多小步, 每执行完一小步就让应用逻辑执行一会儿, 这样交替多次后完成一轮 GC 标记
V8 对这两个问题对应的解决方案分别是三色标记法与写屏障

#### 三色标记法

如果采用非黑即白的标记策略, 那在垃圾回收器执行了一段增量回收后, 暂停后启用主线程去执行了应用程序中的一段 JavaScript 代码, 随后当垃圾回收器再次被启动, 这时候内存中黑白色都有, 我们无法得知下一步走到哪里了

为了解决这个问题, V8 采用了一种特殊方式: 三色标记法
白色指的是未被标记的对象
灰色指自身被标记, 成员变量 (该对象的引用对象) 未被标记
黑色指自身和成员变量皆被标记

从一组根对象开始, 先将这组根对象标记为灰色并推入到标记工作表中, 当回收器从标记工作表中弹出对象并访问它的引用对象时, 将其自身由灰色转变成黑色, 并将自身的下一个引用对象转为灰色

采用三色标记法后我们在恢复执行时就好办多了, 可以直接通过当前内存中有没有灰色节点来判断整个标记是否完成, 如没有灰色节点, 直接进入清理阶段, 如还有灰色标记, 恢复时直接从灰色的节点开始继续执行就可以

三色标记法的 mark 操作可以渐进执行的而不需每次都扫描整个内存空间, 可以很好的配合增量回收进行暂停恢复的一些操作, 从而减少 全停顿 的时间

暂停 GC 执行期间, 如果应用线程对一些对象的指向做了修改, 等到继续 GC 执行时, 标记其实就已经不对了
为了解决这个问题, V8 使用写屏障机制(增量中修改引用), 即一旦有黑色对象引用白色对象, 该机制会强制将引用的白色对象改为灰色, 从而保证下一次增量 GC 标记阶段可以正确标记, 这个机制也被称作 强三色不变性

#### 惰性清理

当增量标记完成后, 假如当前的可用内存足以让我们快速的执行代码, 其实我们是没必要立即清理内存的, 可以将清理过程稍微延迟一下, 让 JavaScript 脚本代码先执行, 也无需一次性清理完所有非活动对象内存, 可以按需逐一进行清理直到所有的非活动对象内存都清理完毕, 后面再接着执行增量标记

### 并发回收

辅助线程在执行垃圾回收的时候, 主线程也可以自由执行而不会被挂起, 这是并发的优点, 但同样也是并发回收实现的难点, 因为它需要考虑主线程在执行 JavaScript 时, 堆中的对象引用关系随时都有可能发生变化, 这时辅助线程之前做的一些标记或者正在进行的标记就会要有所改变, 所以它需要额外实现一些读写锁机制来控制这一点
