# V8 垃圾回收

JS 垃圾回收机制的原理是: 定期找出那些不再用到的内存（变量），然后释放其内存

只能定期执行而无法实时做到，因为开销过大

## GC 算法

常见有 标记清除算法 引用计数算法

### 标记清除算法

此算法分为 标记 和 清除 两个阶段，标记阶段为所有活动对象做上标记，清除阶段把没有标记（也就是非活动）的对象销毁

标记的方法很多
标记的策略是：

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成 1
- 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收

标记清除算法的优点只有一个，那就是实现比较简单
标记清除算法有两个很大的缺点：内存碎片化，分配速度慢

- 清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片
- 新建对象分配内存时，需要对空闲内存列表进行一次单项遍历，找到足够尺寸的空间才能为其分配内存

所以通过 标记整理 算法解决这个问题
标记阶段和标记清除算法相同，标记结束后，标记整理算法会将活着的对象向内存的一端移动，最后清理掉边界的内存

### 引用计数算法

这其实是早先的一种垃圾回收算法
它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`，如果没有了，对象将被垃圾回收机制回收
目前很少使用这种算法了，因为它的问题很多

循环引用时，变量的引用计数会无法归 0 导致内存泄漏

引用计数算法优点是可以立即回收，而不需要定期执行 GC 导致暂停 JS 运行中的线程，也不需要遍历
缺点是无法解决循环引用无法回收的问题，以及计数器需要占很大位置，因为没有办法知道被引用的数量上限

## V8 对 GC 的优化

### 分代式垃圾回收

因为 GC 每次回收时候都要检查内存中的所有对象，
这样对一些大、老、存活时间长的对象和新、小、存活时间短的对象的检查频率一样，因为前者不需要频繁清理，后者需要频繁清理

V8 的策略是将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器进行回收

#### 新生代

新生代容量比较小，通常只有 1-8M
使用 Scavenge 算法进行垃圾回收，而 Scavenge 算法又基于 Cheney 算法

Cheney 算法将新生代内存分为使用区和空闲区
新加入的对象会存放到使用区，当使用区快被写满时候就执行一次 GC
标记阶段，垃圾回收器会对使用区的活动对象做标记，标记完成后将它们复制到空闲区并排序，
清理阶段，垃圾回收器将非活动对象占用的空间清理掉，最后进行角色互换，把原来的使用区变成空闲区，把原理的空闲区变成使用区

当一个对象经过多次复制后仍然存活，就被认为是生命周期比较长的对象，随后会被移动到老生代
还有一种情况是，假如一个对象到空闲区时，空闲区空间占用超过了 25，那么这个对象会被直接晋升到老生代空间，这是因为完成回收后空闲区要反转成使用区继续进行对象内存的分配，如果占比过大，会影响后续使用

#### 老生代

老生代就是通过常规的标记清除进行 GC，并通过标记整理解决内存碎片化问题

### 并行回收

进行垃圾回收时会阻塞 JS 脚本的执行，叫做全停顿（Stop-The-World）
并行回收指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作
新生代对象空间就采用并行策略，启动了多个线程来负责新生代中的垃圾清理操作