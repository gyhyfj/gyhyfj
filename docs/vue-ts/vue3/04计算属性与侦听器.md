# 计算属性与侦听器

## computed

omputed() 方法期望接收一个 getter 函数，返回值为一个计算属性 ref，
在 script 中需要通过`.value`来访问计算结果，计算属性 ref 也会在模板中自动解包。

Vue 的计算属性会自动追踪响应式依赖。

```vue
<script lang="ts" setup>
import { ref, computed } from 'vue'

let firstName = ref('')
let lastName = ref('')
const name = computed(() => firstName.value + ' ' + lastName.value)
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
  <br />
  {{ name }}
</template>
```

计算属性也可以通过同时提供 getter 和 setter 来创建
计算属性默认仅能通过计算函数得出结果。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建：

```vue
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    ;[firstName.value, lastName.value] = newValue.split(' ')
  },
})
</script>
```

现在当你再运行 fullName.value = 'John Doe' 时，setter 会被调用而 firstName 和 lastName 会随之更新。

注意：计算函数不应有副作用，不要在计算函数中做异步请求或者更改 DOM。
注意：避免直接修改计算属性值，从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”。

## watch

侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数

```ts
// 侦听单个来源
function watch<T>(
  source: WatchSource<T>,
  callback: WatchCallback<T>,
  options?: WatchOptions
): StopHandle

// 侦听多个来源
function watch<T>(
  sources: WatchSource<T>[],
  callback: WatchCallback<T[]>,
  options?: WatchOptions
): StopHandle

type WatchCallback<T> = (
  value: T,
  oldValue: T,
  onCleanup: (cleanupFn: () => void) => void
) => void

type WatchSource<T> =
  | Ref<T> // ref
  | (() => T) // getter
  | T extends object
  ? T
  : never // 响应式对象

interface WatchOptions extends WatchEffectOptions {
  immediate?: boolean // 默认：false
  deep?: boolean // 默认：false
  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'
  onTrack?: (event: DebuggerEvent) => void
  onTrigger?: (event: DebuggerEvent) => void
}
```

例子：
a. 侦听简单数据类型：用 ref 包裹成响应式对象（不包裹是不能作为参数传入 watch API 的）

```vue
<script lang="ts" setup>
import { ref, watch } from 'vue'
let name = ref('')
watch(
  name,
  (newVal, oldVal) => {
    // newVal和oldVal自动解包，不需要加`.value`
    console.log(newVal)
    console.log(oldVal)
  },
  { immediate: true } // 可选参数
)
</script>

<template>
  <input type="text" v-model="name" />
</template>
```

b. 侦听复杂数据类型，但用的仍是 ref 包裹

```vue
<script lang="ts" setup>
import { ref, watch } from 'vue'
let name = ref({
  firstName: '',
  lastName: '',
})
watch(
  name,
  (newVal, oldVal) => {
    console.log(newVal)
    console.log(oldVal)
  },
  { immediate: true, deep: true } // 需要加deep:true才能侦听到属性值的变化
)
</script>

<template>
  <input type="text" v-model="name.firstName" />
  <input type="text" v-model="name.lastName" />
</template>
```

c. 侦听复杂数据类型，但用的仍是 reactive 包裹

```vue
<script lang="ts" setup>
import { reactive, watch } from 'vue'
let name = reactive({
  firstName: '',
  lastName: '',
})
watch(
  name,
  (newVal, oldVal) => {
    console.log(newVal)
    console.log(oldVal)
  },
  { immediate: true } // reactive包裹自动实现深度侦听，不需要加deep:true
)
</script>

<template>
  <input type="text" v-model="name.firstName" />
  <input type="text" v-model="name.lastName" />
</template>
```

d. 侦听复杂数据类型，如对象，但只侦听对象的某一个属性
传入 watch API 的第一个参数采用回调函数返回值的写法，如果是 ref 包裹，写作` () => name.value.firstName`。如果是 reactive 包裹，写作` () => name.firstName`

```ts
<script lang="ts" setup>
/* 使用ref包裹 */
// import { ref, watch } from 'vue'
// let name = ref({
//   firstName: '',
//   lastName: '',
// })
// watch(
//   () => name.value.firstName,
//   (newVal, oldVal) => {
//     console.log(newVal)
//     console.log(oldVal)
//   },
//   { immediate: true, deep: true }
// )

/* 使用reactive包裹 */
import { reactive, watch } from 'vue'
let name = reactive({
  firstName: '',
  lastName: '',
})
watch(
  () => name.firstName,
  (newVal, oldVal) => {
    console.log(newVal)
    console.log(oldVal)
  },
  { immediate: true, deep: true }
)
</script>

<template>
  <input type="text" v-model="name.firstName" />
  <input type="text" v-model="name.lastName" />
</template>
```

## watchEffect

立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。

第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求 (参见下面的示例)。
第二个参数是一个可选的选项，可以用来**调整副作用的刷新时机**或**调试作用的依赖**。
返回值是一个用来停止该副作用的函数。

a. 自动检测依赖

```vue
<script lang="ts" setup>
import { ref, watchEffect } from 'vue'

let firstName = ref<string>('')
let lastName = ref<string>('')
watchEffect(() => {
  console.log(firstName.value)
  console.log(lastName.value)
})
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
</template>
```

b. 自动实现深度侦听

```vue
<script lang="ts" setup>
import { ref, watchEffect } from 'vue'
let name = ref({
  firstName: '',
  lastName: '',
})
watchEffect(() => {
  console.log(name.value.firstName)
  console.log(name.value.lastName)
})
</script>

<template>
  <input type="text" v-model="name.firstName" />
  <input type="text" v-model="name.lastName" />
</template>
```

c. 副作用函数的参数，也是一个函数，要做的事定义在副作用函数体内，接受一个回调函数，在副作用函数其他语句执行前执行。
可以做一些事情，比如防抖，比如清除接口 // TODO

```vue
<script lang="ts" setup>
import { ref, watchEffect } from 'vue'

let firstName = ref<string>('')
let lastName = ref<string>('')
watchEffect(onCleanup => {
  console.log(firstName.value)
  console.log(lastName.value)
  /**
   * 副作用函数的参数，也是函数
   * 函数定义在这里，参数是一个回调函数
   * 这个回调函数的执行会在副作用函数其他语句之前
   */
  onCleanup(() => {
    console.log('before')
  })
})
</script>

<template>
  <input type="text" v-model="firstName" />
  <input type="text" v-model="lastName" />
</template>
```

d. watchEffect 的返回值，是一个停止侦听的**函数**

```ts
const stop = watchEffect(() => {})

// 当不再需要此侦听器时:
stop()
```

e. watchEffet 的配置选项
例如，通过添加配置 `{flush："post"}` 可以在 DOM 更新后运行副作用

```vue
<script lang="ts" setup>
import { ref, watchEffect } from 'vue'

let name = ref<string>('')
// let ipt: HTMLInputElement = document.querySelector('#ipt') as HTMLInputElement
// 如果在 watchEffect 外面拿 DOM 元素，那么 watchEffect 中怎么打印都是 null
watchEffect(
  onCleanup => {
    console.log(name.value)
    let ipt: HTMLInputElement = document.querySelector(
      '#ipt'
    ) as HTMLInputElement
    console.log('ipt:', ipt)
    onCleanup(() => {
      console.log('before')
    })
  },
  {
    flush: 'post',
  }
)
</script>

<template>
  <input id="ipt" type="text" v-model="name" />
</template>
```
