# 指令与自定义指令

## v-on

监听 DOM 事件 `v-on` 缩写 `@` 指令：
事件处理器的值可以是：

1. 内联事件处理器，传入一个 JS 表达式
2. 方法事件处理器，传入一个方法

```vue
<!-- 方法事件处理器 -->
<button @click="addCount">Add Count</button>

<!-- 内联事件处理器 -->
<button @click="addCount()">Add Count</button>

<!-- 内联事件处理器 -->
<button @click="count++">Add Count</button>

<!-- 内联事件处理器 -->
<button
  @click="
    () => {
      count++
    }
  "
>Add Count</button>
```

### 事件传参

如果是 方法事件处理器，
`@click="addCount"`，定义事件处理函数 addCount 时候，第一个形参会默认是事件对象，其他多余参数是 undefined

如果是 内联事件处理器，

1. 向该处理器方法传入一个特殊的 `$event` 变量`@click="addCount( $event)"`，事件处理函数对应`$event`位置的形参会自动接收这个事件对象
2. 使用携带一个事件对象的箭头函数 `@click="e=>addCount(e)"`，事件处理函数对应**箭头函数第一个未指定值的那个参数**位置的形参会自动接收这个事件对象

### v-on 事件修饰符

希望方法能更专注于数据逻辑而不用去处理 DOM 事件的细节，
不在方法中执行 event.preventDefault() 或 event.stopPropagation() 这样的语句

.stop // 阻止冒泡
.prevent // 阻止默认行为
.self // e.target 是元素本身时候才会触发
.capture // 指向内部元素的事件，在被内部元素处理前，先被外部处理
.once // 点击事件最多被触发一次
.passive // 一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能

```vue
<!-- 滚动事件的默认行为 (scrolling) 将立即发生而非等待 `onScroll` 完成 -->
<!-- 以防其中包含 `event.preventDefault()` -->
<div @scroll.passive="onScroll">...</div>
```

注意：

1. 修饰符可以使用链式书写，但要注意书写顺序，因为相关代码是以相同的顺序生成的，所以：
   `@click.prevent.self` 会阻止元素及其子元素的所有点击事件的默认行为
   `@click.self.prevent` 则只会阻止对元素本身的点击事件的默认行为。

2. 请勿同时使用 .passive 和 .prevent，因为 .passive 已经向浏览器表明了你不想阻止事件的默认行为。如果你这么做了，则 .prevent 会被忽略，并且浏览器会抛出警告。

### v-on 按键修饰符

https://cn.vuejs.org/guide/essentials/event-handling.html#event-modifiers

按键别名
.enter
.tab
.delete (捕获“Delete”和“Backspace”两个按键)
.esc
.space
.up
.down
.left
.right

系统按键修饰符
.ctrl
.alt
.shift
.meta

exact 修饰符
.exact

鼠标按键修饰符
.left
.right
.middle

### 绑定多个事件处理函数

不可以用：

1. 不可以用`@click="fn1", @click="fn2"`
2. 不可以用`@click="fn1, fn2"`
3. 不可以用`@click="fn1(); fn2()"`
4. 不可以用`@click=""`

可以用：

1. `@click=()=>{print(); addCount()}`
2. `@click="语句1, 语句2"` 比如： `@click="print(),addCount()"` 或 `@click="count++,addCount()"`

## 事件处理函数的防抖与节流

绑定多个事件处理函数，不改变函数本身的防抖、节流特性

如果写成 `@click="debounce(handleClick)"` 则函数不会生效
但如果写成 `@click="debouncex(handleClick)()"` 则函数会生效

原因很简单，第一种写法，被认为接收了一个内联事件处理器而非函数表达式，点击后只会触发执行 debounce 函数
第二种写法，最后一个括号之前无论如何都会被认为是一个函数表达式，返回一个匿名函数，结合后面的括号构成内联事件处理器

所以：必须要把防抖函数生成到调用外面，或写成生成的防抖函数的调用语句

### 注意：

内联事件处理器 不能使用 web api
不可以：

1. 不可以`@click="console.log(9)"`
2. 不可以`@click="()=>{console.log(9)}"`
3. 不可以`@click="function (){console.log(9)}"`

## 自定义指令

除了 Vue 内置的一系列指令 (比如 v-model 或 v-show) 之外，Vue 还允许你注册自定义的指令。
自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。

一个自定义指令被定义为一个包含类似于组件的生命周期钩子的对象

### 基本用法

引入 Directive，
自定义一个类型为 Directive 的 v 开头特定形式的变量，指向一个对象，里面每一项对应生命周期函数的 api
使用时用`v-`的小写形式，可以带参数、赋值等

```ts
const myDirective: Directive = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode, prevVnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount() {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted() {},
  // 绑定元素的父组件更新前调用
  beforeUpdate() {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated() {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount() {},
  // 绑定元素的父组件卸载后调用
  unmounted() {},
}
```

其中：
el：指令绑定到的元素。这可以用于直接操作 DOM。
binding：一个对象，包含以下 property：

1. value：传递给指令的值，例如在 v-my-directive="1 + 1" 中，值是 2。
2. oldValue：之前的值
3. arg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 "foo"。
4. modifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。
5. instance：使用该指令的组件实例。
6. dir：指令的定义对象。

注意：
除了 el 外，你应该将这些参数都视为只读的，并一律不更改它们

可以**对 el 进行 dom 操作**，用到其他参数的值

### 简写

对于自定义指令来说，需要在 mounted 和 updated 上实现相同的行为、又并不关心其他钩子的情况很常见。

下面例子中的正方形会随输入框中输入颜色的改变而改变

```vue
<!-- A.vue -->
<template>
  <div style="width:300px; height:300px"></div>
</template>
```

```vue
<!-- App.vue -->
<script lang="ts" setup>
import { ref, Directive, DirectiveBinding } from 'vue'
import A from './components/A/A.vue'

let value = ref<string>('')
type Dir = {
  background: string
}

const vMove: Directive = (el: HTMLElement, binding: DirectiveBinding) => {
  el.style.background = binding.value.background
}
</script>

<template>
  <input type="text" v-model="value" />
  <A v-move:arg.xxx="{ background: value }" />
</template>
```

### 案例：拖拽效果

```vue
<!-- A.vue -->
<template>
  <div></div>
</template>

<style scoped>
div {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 100px;
  height: 100px;
  background: pink;
}
</style>
```

```vue
<!-- App.vue -->
<script lang="ts" setup>
import { Directive, DirectiveBinding } from 'vue'
import A from './components/A/A.vue'

const vMove: Directive = (el: HTMLElement, binding: DirectiveBinding) => {
  const mouseDown = (e: MouseEvent) => {
    let x = e.clientX - el.offsetLeft
    let y = e.clientY - el.offsetTop
    const mouseMove = (e: MouseEvent) => {
      console.log(e)
      el.style.left = e.clientX - x + 'px' // A 是绝对定位
      el.style.top = e.clientY - y + 'px'
    }
    document.addEventListener('mousemove', mouseMove)
    document.addEventListener('mouseup', () => {
      document.removeEventListener('mousemove', mouseMove)
    })
  }
  el.addEventListener('mousedown', mouseDown)
}
</script>

<template>
  <A v-move />
</template>
```
