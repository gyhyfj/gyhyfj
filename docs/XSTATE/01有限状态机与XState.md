# 有限状态机与 XState

## 业务需求

### 现状分析

长期迭代的变化：
代码行数-时间 diagram
相同一个需求，在项目初期可能一天就能完成，但在项目长期迭代后，可能要 3 天甚至更多时间才能完成
后期项目种代码状态的维护成本太高，做到最后经常出现牵一发而动全身的一些情况，这是抑制业务迭代速度的根本原因

影响项目交付时长的因素：
项目复杂度
泰斯勒定律（复杂度守恒定律）
每个应用程序都具有其内在的、无法简化的复杂度。这一固有的复杂度都无法依照我们的意愿去除，只能设法调整、平衡。 <!-- TODO 不理解是什么意思 -->
复杂度无法减小，但可以拆分
前端复杂度拆解：
框架（vue react） 通用组件(antd vant) 业务组件(sfc) 业务逻辑
前面几个不管怎么更换和优化对复杂度的承担是微乎其微的

业务逻辑逐渐复杂带来的问题：
一、flag 变量暴增代理可读性差的问题，flag 变量多了很难清楚直到每一个变量到底是干什么的
二、逻辑代码散落在各处，这会导致在新增或修改一个功能的时候，要去刻意地寻找可能影响和可能关联的部分，进行同步修改。但这一步很容易遗漏产生一些 bug
三、协作成本、PD 预判能力、确切的测试范围、同角色间的合作
一个纯粹的开发人员，通常没有业务视角，会直接导致无法排除产品需求文档中可能存在的不合理地方，导致未来额外优化时带来的成本
大部分情况下需要你给处一块需要测试的范围给测试同学，如果开发人员都不确定改动点会影响哪些页面，测试同学被迫只好 全量回归系统，是对测试同学的不负责，因为大系统中回归成本是非常巨大的
如果项目中有新人加入或交接给其他人，会在业务逻辑和业务代码匹配上花费大量时间，很难快速地参与 进来

项目文档（是否说清楚，让每个人都理解）
产品需求文档 PRD 说清产品的功能，但并不会去写交互的细节，并且通常 PRD 是很冗长的
交互设计稿 静态描述交互逻辑细节，渲染逻辑，但是完备起来需要花费大量的时间，业务通常不会给大量时间
流程图 同样的问题-大概的业务逻辑，缺少交互细节
上述三种都无法做到实时的同步，在有些情况下，中途调整的需求尤其是相对较小的，其实很少有去同步到文档中的，虽然这是不规范的，但确实经常发生，而这也为后面的沟通，以及未来的复盘产生比较严重的影响

多角色间的上下游依赖

业务方（提出想要的功能） - 产品经理（梳理功能并书写 PRD） - 设计师（根据 PRD 制订交互设计稿） - 评审（需求评审及设计评审，不通过则返回产品经理） - 后端、前端开发，联调 - 测试 - UAT(用户验收测试，不满足用户或需求上和用户想法不一致，则返回产品经理) - 发布上线

相当耗时，多角色间存在明显的上下游依赖，没办法沟通发力来加快迭代的速度
前面的部分如果处理不当，是很很容易占用后面角色的时间的
作为纯粹的开发者，如果没有业务视角，很难发现 PD 需求中可能存在的问题和错误，这就间接导致 UAT 阶段反修的概率提升 （非常不希望看到）

### 基于状态机的解法

状态机就是用来解决基于行为的复杂状态维护问题的，
并且有效解决文档和角色间的串行问题

<!-- TODO TDD -->

状态模式：
把状态的判断逻辑转移到表示不同状态的一系列类当中，减少相互间的依赖，可以把复杂的判断逻辑简化
将与特定状态相关的行为局部化，并且将不同状态的行为分割开来

状态机：
FSM 又称 FSA （automaton） 是现实事物运行规则抽象而成的一个数学模型 是一种认知论

状态机包含五个重要部分：
初始状态值 (initial state)
有限的一组状态 (states)
有限的一组事件 (events)
由事件驱动的一组状态转移关系 (transitions)
有限的一组最终状态 (final states)
共三类：状态 事件 转移关系

解决业务逻辑问题：
传统实现方式
搜索框示例
点击搜索按钮，调用 onSearch 方法，方法内会携带搜索关键字进行请求，并把请求结果显示在视图中的结果框内，看起来实现挺简单的，只有几行代码
->
如果接口比较慢，需要给用户一个预期的交互，像一些 loading 效果（创建 isLoading 布尔值并设为 true）
->
接口可能出错，需要处理这部分异常（创建 isError 变量并设为 true）。处理异常时不能忘记把 loading 效果同步关掉（isLoading 设为 false）。重新搜索时需要再把错误状态关掉（前面 onSearch 方法的 isError 设为 false）
->
当用户在搜索请求中，搜索按钮点击不应该再去发请求，（onSearch 方法内写一个判断语句，isLoading 则 return）
->
如果搜索结果特别慢，需要提供中断搜索的功能，那么新的需求就又来了，要添加一个取消方法 onCancel，同时不能落下对错误捕捉的特殊处理，因为中断请求也会触发 catch，但不是走请求出错的逻辑，不应该让 isError 为 true
->
还要处理没有值的情况（catch 语句中 e&&e.name）

传统实现方式：应用的复杂度在完善需求的同时不断在变大
这种包含各种 flag 变量和嵌套 各种 if/else 的代码，会越来越难维护，所有的逻辑只存在于写下这段代码的人的脑子里，当写测试时必须从头再梳理一遍代码的逻辑才可能写出来
在一些高频变化的业务场景，很多业务的开发人员其实是不写测试的，因为写单元测试的成本太高太高。这也导致项目交付给其他人的时候，别人去理解你的代码时是一件很困难的事（这个变量是干啥的，为什么这个地方要把这个变量设为 false 之类，这么多 if else 分别是啥情况...）。即便是写代码的人自己，当项目迭代久了，自己也不理解为什么要写成这样的逻辑
传统实现方式 是 自底向上实现
从解决问题的最基本层面开始，然后逐步拓展解决方案的多个部分
bottom-up code：
difficult to understand
difficult to test
will contain bugs
difficult to enhance
It's hard to add new feature because you have to make sure that none of your other code will break ,
and also adding features makes it worse because it increases the complexity of the code,
so there's many problems to this bottom-up approach.

而基于状体机的实现，则是只要定义好空闲 搜索中 成功 失败 四种状体就可以，并且可以被可视化出来
可以清晰地看到有哪些状态，每个状态可以接受哪些事件，接受到事件后又会转移到什么状态，以及到达某个状态的路径是怎么样的

用状态机如何项目文档：

状态机可视化：状态图
更精确的符号系统- 状态图
w3C 关于状恣图的推荐规范叫 SCXML - SCXML ( State Chart XML )，用于控制抽象的状态机表示法
它是基于 David Harel 状态图和 CCXML ( Call Control eXtensible Markup Language )进行扩展而来的一套规范

状态图带来了： 一套非常复杂且精确的符号系统 结构层次的表达能力 有向图的连通表达能力
使用它 在开发前 必须把所有可能的状态都罗列出来，状态之间的关联关系也必须描述清晰

减少角色依赖关系：
由于使用前必须先对项目系统进行建模，否则是无法写代码的 （这是和传统编程方式的区别，是无法绕开的）
而在建模时，需要把所有可能的状态全部考虑进来，这迫使你必须熟悉业务
（某种意义上，是将阻塞转移到了设计阶段，但仍能减少阻塞。即使对效率不会有明显提升，但是质量和开发体验上有提升很大）

基于这种新模式的链路：

业务方 - 产品经理 - 前端 （提前参与进来，在对需求进行建模的过程中，大致就可以发现产品需求中可能存在的一些逻辑问题，避免后续的一些出错概率）+ 设计师（额外地也可以根据状态图中的不同状态，来确定哪种状态适合用什么样的交互）（同时这份状态图也将前端原本需要写的巨量判断逻辑给抽离出来，减轻了负担）+ 测试（也可以提前参与进来，进行逻辑验证） - 评审 - 前后端开发 - 测试（工作量已经很低了，可以直接用机器去根据模型去生成测试，实现端到端测试<!-- TODO -->） - UAT（到了这个环节，一些逻辑的错误基本是不会发生的，有效减少了这个环节提交需求变更的概率） - 发布交付

新模式带来的好处：
容易理解，因为是从业务视角去建模的，并且是可视化的
容易扩展，因为它是基于行为建模的，与视图完全解耦开的，不再是传统的将行为与业务逻辑耦合在一起，更容易改变行为，更容易测试
业务视角：参与人员对业务有一个比较全面的了解，有更强的业务视角，在你写代码的同时，也让你向业务专家的方向靠近
减少出错：bug 能减少 80%-90%，且 bug 很少出现在状态图本身

新模式带来的问题：
思维的转变：状态机模式是一种范式的转变，需要面对新的格式，新的重构技术，新的调试工具，需要成员走出舒适圈，客服抵触心理
认知不一致：成员可能会觉得这个东西没什么用，使用最简单的方式去实现的心态，开发人员不会注意到复杂度的蔓延，随着系统的迭代和变大，一个个 if/else 语句，维护着变化的状态。当需要状态机时，已为时已晚。对于复杂迭代的项目，非常不建议前期简单做
团队内不同阻力：很多人不会，需要学习用新的模式该如何去写，所以团队内必须有人基于这种模式去实践过，并且对他非常了解才可以，否则这种新模式很可能让团队无从下手，令人生畏

## 有限状态机

有限状态机是一种数学计算模型，它描述了在任何给定时间只能处于一种状态的系统的行为

有限状态机有五个部分：
有限的 状态
有限的 事件
一个 初始状态
在给定当前状态和事件的情况下，确定下一个状态的 转换函数
一组（可能是空的）最终状态

这里的状态是 state，而不是 data

任何具有状态的事物，都会有一个 初始状态，即进程存在的默认状态，直到发生事件，从而改变事物的状态。

大多数具有状态的进程都会有一个 最终状态，即进程完成时的最后一个状态

复合状态是可以包含更多状态的状态，也称为子状态。 这些子状态只能在父级复合状态发生时发生。

原子状态是没有任何子状态的状态

并行状态是一种复合状态，每个并行状态的当前子状态同时处于活动状态。

自转换是指事件发生但转换返回到相同状态时。“一直做某事，但一直没变化”

延迟转换是一种在处于某种状态，达到指定时间长度后，发生的转换

动作 Actions 通常也称为 作用（effects） 或 副作用（side-effects）
动作事件，对后续的其余部分没有影响，事件只是被触发，流程还是原来设置的那样，走下一步。

## xstate

XState 是一个状态管理 Library，负责储存及描述各种状态与各种状态间的转换
XState 是对 finite state machines 和 state charts 的实现
API 设计目标是：
遵守 W3C SCXML 规范和 David Harel 的原始状态图形式。
提升演员模型基于事件的架构
兼容所有框架和平台
够将状态机定义完全序列化为 JSON（和 SCXML）
纯函数 API
零依赖

## why xstate

### 缺乏清晰的狀態描述

相比状态分散在不同地方，状态管理十分重要
Flux 出現提出了單一資料源(Single Source of Truth)及單向資料流(unidirectional data flow)等概念後，狀態管理的問題才得到了緩解。而 Redux 的出現利用 Functional Programming 的手法大幅度的降低原先 Flux 的複雜度以及學習成本

但问题是缺乏清晰的狀態描述
不管是使用 Redux 或其他相關的 Library 都會有狀態難以清晰描述的問題
原因是：一、完全混合了狀態(state)跟資料(context)；二、通常都使用 flag 來表達某個小狀態，再由多個 flags 來表達某個狀態，當這種 flag 越來越多時，我們的程式就會很容易出現 Bug

### 過於自由的狀態轉換

過去我們的狀態是由多個 flags 所組成，這導致了我們無法明確的定義各種狀態之間的關係，最後就會變成我們無法確定狀態之間的切換是否正確

### 難以與工程師之外的人討論

當我們今天用各種 flags 的方式去描述整個應用程式的狀態時，其實是很難跟工程師之外的人溝通或討論的，就算是工程師也要追 Code 花時間理解當前的程式到底是如何運作並且在哪個狀態下出現的 Bug，這會讓我們很難快速地發現問題也很難跟 PM 討論需求設計是否存在邏輯上的矛盾，或是有未處理的狀態。

## XState 额外优势

程式碼即 UI Spec
有可视化工具可以使用

寫更少的測試
由於我們已經明確定義出各個狀態以及每個狀態之間的關係，這讓我們可以更輕鬆的撰寫測試，也不需要測試那些根本不可能出現的狀態，並透過 Model-based Testing 我們只需要寫各個狀態下的斷言(assertion)就可以自動把各種狀態切換的路徑都測試完

更快速的路徑優化
通过监听状态转移来埋点
當我們完成一個應用程式時，最需要做的通常就是使用者體驗(User Experience)的優化，我們常常需要利用各種服務來收集各個頁面間的轉化率或是哪些狀態讓使用者最快跳過等等的數據。透過這些數據來優化我們應用程式的流程，讓使用者體驗進一步的提升。而如果使用了 XState 我們就可以在各個狀態轉換之間送 log 到數據收集的服務(如 GA, MIXpanel 等等)，就可以進一步分析哪些狀態可能是不必要的，來優化我們的 User Flow。
