# 函数

一般的函数的形参都是用逗号隔开的一个个形参变量名，
如果是可选参数，ts 下就在类型前加问号，且不再像 js 那样必须放在形参表尾。如果是可选且有默认值参数，就不加类型约束，直接用等号赋值默认值

```ts
const fn = (a?: number, b?: number, c?: number) => ({
  a,
  b,
  c,
})

console.log(fn(1, 2, 3)) // { a: 1, b: 2, c: 3 }
console.log(fn(1, 2)) // { a: 1, b: 2, c: undefined }

/* 那么如果只像给a和c传参呢？就必须主动给b传个undefined以维持传值给正确的形参 */
console.log(fn(1, undefined, 3)) // { a: 1, b: undefined, c: 3 }
```

函数除了用变量名作为形参外，还可以用对象来作为形参

```ts
// 下例种的number表示是参数的重命名
const fn = ({ a: number }) => {
  // 绑定元素“number”隐式具有“any”类型
  console.log(number)
  console.log(a) // error 找不到名称“a”
}

// 下面的number被认为是类型，不可以这样写
const fn = ({ a?: number }) => { // error number”仅表示类型，但在此处却作为值使用
  console.log(1)
}

const fn = ({ a: number }: any) => {
  // 绑定元素“number”隐式具有“any”类型
  console.log(number)
}
fn({ a: 1 }) // 1
fn({ b: 1 }) // undefined
```

所以怎么理解形参是一个对象?
如果对象中的成员用冒号重命名，则冒号前的键名将不再可被访问

```ts
const fn = ({ a: x, b: y, c: z }: any) => ({
  a,
  b,
  c, // 速记属性 "a" 的范围内不存在任何值。请声明一个值或提供一个初始值设定项。
})
```

也可以不用冒号重命名，直接指定接收的变量名:
这样就能方便地实现准确给可选参数传值

```ts
const fn = ({ a, b, c }: any, d?: number) => ({
  a,
  b,
  c,
})

console.log(fn({ a: 1, c: 3 })) // { a: 1, b: undefined, c: 3 }
```

接受对象这样的引用类型的参数

如果直接把参数赋值为另一个类型，则只是改变形参的指针指向，传入的对象不会改变
如果修改它的成员，那么源数据也会改变，因为指针一直指向它
而如果用 Object.assign 方法则会改变函数外的原对象

```ts
const z = { x: 1 }

const fn = obj => {
  // Object.assign(obj, { y: 1 }) // Object.assign方法会改变函数外的obj

  obj = {
    y: 1,
    ...obj,
  } // 创建了一个新的对象赋值给obj，函数外的obj不会被改变
}

fn(z)

console.log(z)
```
