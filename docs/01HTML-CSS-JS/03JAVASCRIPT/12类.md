# 类

## 声明类

构造器中声明的类的成员需要提前写好，可以通过等号赋予初始值
也可以不写，在构造器的形参上使用 public 关键字

```ts
class User {
  name
  constructor(name: string) {
    this.name = name
  }
}
class User {
  name = 'zs'
  constructor(name: string) {
    this.name = name
  }
}
class User {
  constructor(public name: string) {
    this.name = name
  }
}
```

## 导出类

命名导出`export class User {}`
默认导出`export default class User {}` 写库时不推荐 ESM 的默认导出

## 公有 私有 静态

属性：
默认都是公有，公有的只能通过实例去访问
以`#`开头的字段是私有，可以隐藏内部细节，只暴露有用的接口给外部

静态属性是属于类的，被所有实例共享
如果是公有可以通过类去访问，如果是私有，只能在类内部被访问（可以用来限制创建的实例数等等）

方法：
静态方法是类本身的方法
静态方法 可以访问 静态字段，无法访问 实例字段

## readonly

修饰的变量必须在声明时或在构造时被初始化，且其他地方不能修改

## private protected

private 修饰的成员不能被继承，且不能被实例访问到
protected 修饰的成员可以被继承但不能通过实例访问到

## getter setter 方法

写法是

```ts
class User {
  constructor(public name: string) {}
  get name() {
    return this.name
  }
  set name(name: string) {
    this.name = name
  }
}
```

当把这个字段当变量去取值时，自动走 get，当把这个字段当函数用时，自动走 set

## extends 继承

`class A extends B{}`
此时在子类代码中可以用到关键字 super，
当在子类的 constructor 中时，可以当作父类的构造函数
当在子类的方法中调用时，可以用 super.xxx 取父类的 xxx 方法

子类中定义的方法会覆盖父类的同名方法

## 原型链

instanceof 运算，返回布尔值
子类的实例，同样也是父类的实例

## 抽象类与抽象方法

abstract 抽象类做为其它派生类的基类使用，无法直接被实例化
abstract 抽象方法必须在派生类中被实例化

```ts
abstract class Person {
  abstract ask(): void // 必须在派生类中实现
  run(): void {
    console.log('跑起来，点赞，评论，一键三连')
  }
}
```

## 顺便复习 new 的过程

通过 new 关键字：

1. 在内存中创建一个空的简单 JavaScript 对象（即{}）
2. 为步骤 1 新创建的对象添加属性`__proto__`，将该属性链接至构造函数的原型对象
3. 让 this 指向这个新对象 // 箭头函数没有 this，所以不能成为构造函数
4. 执行构造函数里面的代码，给这个新对象添加属性和方法
5. 如果该函数没有返回对象，则返回这个新对象。
