# 常用代码

## 防抖和节流

解决的问题：高频的操作带来的函数多次调用问题
比如：页面滚动 视口大小改变 输入框输入 键盘操作 连续点击提交按钮

防抖：在一定时间间隔 N 秒后才执行该事件，如果在 N 秒内被重复触发，则重新计时
比如：输入框连续输入值，只等最后一次输入完成才触发查询的动作
比如：点赞、表单提交等动作，防止重复提交

节流：在 N 秒内最多只运行一次，如果 N 秒内重复触发，只有第一次生效 `throttle [ˈθrɑːtl]`
比如：监听页面滚动到底部时触发的事件，固定时间内只执行一次
比如：拖拽事件，固定时间内只执行一次

防抖函数

```js
/**
 * debounce 接收一个回调函数fn和可选参数delay
 * 返回一个匿名函数，这个匿名函数在合适的时机把自己接收的参数交给fn去执行
 * 动作全部停止delay毫秒后才执行一次fn
 * delay内重新触发动作，则重新计时
 * fn.apply(this, rest) 相比 fn(...rest) 是为了确保this指向不出问题
 */
function debounce(fn, delay = 200) {
  // 下面这个语句不能写在返回的匿名函数中，那样会每次点击都连续执行两次回调函数
  let timeout = null
  // 返回一个匿名函数，这个匿名函数其实能访问到外界变量timeout fn 和delay
  return function (...rest) {
    // 判断事件触发时，定时器是否存在，如果存在就把它清掉重新计时
    if (timeout) {
      // 清空当前定时器，在下文中设置新定时器
      clearTimeout(timeout)
      // TODO: 释放内存？
      timeout = null
    } else {
      // else语句块可选，是否在第一次触发时调用回调
      // 如果写了这个语句，第一次触发事件，会调用两次fn，这是提交表单不能接受的
      fn.apply(this, rest)
    }
    timeout = setTimeout(() => {
      fn.apply(this, rest)
    }, delay)
  }
}

/**
 * 使用防抖函数
 * 定义一个 fn
 * 然后 fn = debounce(fn)
 * 把 fn 作为事件处理函数绑使用
 */
```

TS 箭头函数写法

```ts
const debounce = (fn: Function, delay = 2000) => {
  let timeout: number // TODO: 数据类型
  return (...rest: any[]) => {
    if (timeout) {
      clearTimeout(timeout)
      // TODO: 是否要=null，是释放内存吗，可是明明是number类型
    } else {
      fn(...rest)
    }
    timeout = setTimeout(() => {
      fn(...rest)
    }, delay)
  }
}
```

节流函数：

```js
/**
 * throttle 接收一个回调函数fn和可选参数delay
 * 返回一个匿名函数，这个匿名函数在合适的时机把自己接收的参数交给fn去执行
 * 每个delay时间周期内只执行一次
 */
function throttle(fn, delay = 200) {
  // 获取事件触发时间
  let preTime = Date.now()
  return function (...rest) {
    // 获取事件触发时间
    nowTime = Date.now()
    // 如果两次触发间隔大于delay
    if (nowTime - preTime >= delay) {
      // 把外部变量preTime赋值为当前时间
      preTime = nowTime
      // 调用fn并返回
      return fn.apply(this, rest)
    }
  }
}
```

## 深拷贝

这里是数组或对象的深拷贝方法，但非常有局限性，
只有确保传入的对象及里面每个成员都是数组、对象或基本数据类型，才能适用

```js
/**
 * 数组或对象的深拷贝方法
 * 接收一个obj，返回一个深拷贝的obj
 * obj 这里只能是数组或对象
 */
function deepCopy(obj) {
  // 如果不是obj就返回
  if (!obj || typeof obj !== 'object') return

  // 判断要复制的是数组还是对象
  let newObj = Array.isArray(obj) ? [] : {}
  // for in 循环
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      // 递归调用，直到 obj[key] 不再是对象或数组
      newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]
    }
  }
  return newObj
}
```
