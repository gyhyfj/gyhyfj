# 遍历

## for in

for in 遍历对象的可枚举属性的 key，如果是数组对象，那么就以数组的索引为 key，数据类型是 string
可枚举属性【js 自定义属性】/不可枚举属性【对象的内置属性】

for in 以原始插入顺序迭代对象的可枚举属性

```ts
// @ts-nocheck
let arr = ['a', 'b', 'c']
arr.dog = 9 // 给对象arr增加一个新属性'dog'

for (let i in arr) {
  console.log(i, arr[i]) // '0' '1' '2' 'dog'
}
```

for in 会遍历从原型链上继承的全部可枚举属性，性能很差，并且可能会导致代码中出现意外的错误
可以用 Object.prototype.hasOwnProperty()检查是否是继承的属性

```ts
// @ts-nocheck
let arr = ['a', 'b', 'c']
arr.dog = 9 // 给对象arr增加一个新属性'dog'
Array.prototype.testFn = () => {}

for (let i in arr) {
  console.log(i, arr[i]) // '0' '1' '2' 'dog' 'testFn'
  console.log(arr.hasOwnProperty(i)) // true true true true false
}
```

## for of

for of 遍历对象的可枚举属性的 value
for of 在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环
for of 不遍历通过原型链继承的属性的 value

for of 不可遍历普通对象，除非结合 Object.keys()先拿到这个普通对象的 key 数组，然后再对这个数组进行遍历
Object.keys()不会返回通过原型链继承的属性

```ts
let obj = {
  x: 1,
  y: 1,
}

for (const i of Object.keys(obj)) {
  console.log(i, obj[i]) // x 1 y 1
}
```

## forEach

forEach() 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。

forEach() 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach() 遍历到他们那一刻的值。

```js
arr.forEach(element => {
  /* ... */
})
arr.forEach((element, index) => {
  /* ... */
})
arr.forEach((element, index, array) => {
  /* ... */
})
```

如果原数组是基本类型，forEach() 不会改变原数组元素
如果原数组是引用类型，forEach() 不会改变原数组元素指向，但可以改变指向下的内容

```js
// 基本类型
let arr = [1, 2, 3]

arr.forEach(item => (item += 3))
console.log(arr) // [ 1, 2, 3 ]

// 引用类型
let arr = [[1], [2], [3]]

arr.forEach(item => item.push(9))
console.log(arr) // [ [ 1, 9 ], [ 2, 9 ], [ 3, 9 ] ]
```

## 循环中的异步

如果是在循环外定义了一个 promise，循环中哪一步走到 await 这个 promise 时候会等待直到 resolve 或 reject，之后的循环中遇到这个 promise 因为已经不再是 pending 状态所以会不需要再等待

如果是每次循环中遇到的都是不同的 promise（比如通过函数去生成）那么每轮循环中只要遇到 await 这个 promise 都会等到最终 resolve 或 reject 时候才执行下文的逻辑并进入后面的循环

```ts
let arr = [1, 2, 3]
const wait = new Promise(res => setTimeout(res, 1000))

const fn = async () => {
  for (let value of arr) {
    await wait
    console.log(value) // <等待> 1 2 3 'end'
  }
  console.log('end')
}

fn()
```

```ts
let arr = [1, 2, 3]
const wait = (s: number) => () => new Promise(res => setTimeout(res, 1000, s))

const fn = async () => {
  for (let value of arr) {
    let b = await wait(value)() // 每次走到这一步都会生成一个新的promise
    console.log(b) // <等待> 1 <等待> 2 <等待> 3 'end'
  }
  console.log('end')
}

fn()
```
