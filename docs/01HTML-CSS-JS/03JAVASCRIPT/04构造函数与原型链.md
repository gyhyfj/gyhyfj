# 构造函数与原型链

## 原型

每个函数都有一个显式原型`prototype`，`func.prototype`（箭头函数除外）
每个对象都有一个隐式原型`__proto__`，`obj.__proto__`

注意理解这里的“有”，因为 JS 一切皆对象，所以这里的“有 prototype”相当于是有 prototype 这个属性，它的值是一个引用类型，所以说“指向”另一个什么对象

构造函数的显式原型，默认有两个属性，
一个是 constructor，指向构造函数本身
另一个是隐式原型`__proto__`，指向它的上一级的原型
除了这两个以外还有 构造函数挂载到 prototype 上的公有属性方法

实例对象的隐式原型，指向它构造函数的显式原型

```js
function Point(x, y) {
  this.x = x
  this.y = y
  this.z = 0
}
const point = new Point(1, 1)

console.log(point.z) // 0
console.log(Point.prototype) // 函数的显式原型
/*
 * {
 *   constructor: f Point(x,y),
 *   [[prototype]]: Object
 * }
 *
 * 构造函数的显式原型，默认有两个属性：
 * 一个是 constructor，指向构造函数本身；
 * 因为它也是对象，所以另一个属性是隐式原型`__proto__`，也就是`[[prototype]]`，指向其上一级的原型
 */

Point.prototype.constructor === Point // true

point.__proto__ === Point.prototype // true
/*
 * 实例对象的`__proto__`，指向它构造函数的显式原型
 * `point.__proto__ === Point.prototype`
 */
```

## 原型链

JS 原型链的本质：建立了对象属性（包括方法）的查找机制：

当**访问某个对象的某个属性或方法的时候**：先查自身，再查其隐式原型，因为它的隐式原型指向它构造函数的显式原型，向上直到 Object.prototype 为止，因为 Object.prototype 的隐式原型为 null
`Object.prototype.__proto__ = null`

`point.__proto__.__proto__.__proto__`
`` point-----(`__proto__`)----->Point.prototype-----(`__proto__`)----->Object.prototype-----(`__proto__`)----->null ``

## 构造函数

构造函数名称首字母通常大写，且内部构造的属性名与方法名之前要加`this.`，调用时要用关键词`new`
一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤

```js
function Point(x, y) {
  this.x = x
  this.y = y
}
```

## 给构造函数添加成员

### 方法一：在构造函数内部添加

```js
function Point(x, y) {
  this.x = x
  this.y = y
  this.print = function () {
    console.log(this.x, this.y) // 一定要用`this.`
  }
}
```

### 方法二：挂载在构造函数 prototype 上

```js
function Point(x, y) {
  this.x = x
  this.y = y
}
Point.prototype.print = function () {
  console.log(this.x, this.y) // 一定要用`this.`
}
```

### 方法三：在构造函数上添加静态成员

静态成员只有构造函数能访问到，实例无法访问到
即不挂载在构造函数 prototype 上，而是直接挂载在构造函数上

```js
function Point(x, y) {
  this.x = x
  this.y = y
  area = 0
}
Point.z = 0

let p = new Point(3, 6)
console.log(p) // Point { x: 3, y: 6 }
console.log(p.z) // undefined
console.log(p.area) // undefined
console.log(Point.z) // 0
```

## 使用构造函数

通过 new 关键字：

1. 在内存中创建一个空的简单 JavaScript 对象（即{}）
2. 为步骤 1 新创建的对象添加属性`__proto__`，将该属性链接至构造函数的原型对象
3. 让 this 指向这个新对象 // 箭头函数没有 this，所以不能成为构造函数
4. 执行构造函数里面的代码，给这个新对象添加属性和方法
5. 如果该函数没有返回对象，则返回这个新对象。

箭头函数是 ES6 中的提出来的，它没有 prototype，也没有自己的 this 指向，所以不能 New 一个箭头函数
