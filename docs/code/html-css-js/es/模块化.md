# 模块化

## 基本思想

模块化是指解决一个**复杂问题**时，自顶向下逐层**把系统划分成若干模块的过程**。对于整个系统来说，**模块是可组合、分解和更换的单元**。

编程领域中的模块化，就是**遵守固定的规则**，把一个大文件拆成**独立并互相依赖**的**多个小模块**。

把代码进行模块化拆分的好处：
① 提高了代码的**复用性**
② 提高了代码的**可维护性**
③ 可以实现**按需加载**

**模块化规范**就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。
使用什么样的语法格式来**引用模块**，在模块中使用什么样的语法格式**向外暴露成员**。

**模块化规范的好处**：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。

## ES6 模块化

### 前端模块化规范

在 ES6 模块化规范诞生之前，JavaScript 社区已经尝试并提出了 AMD、CMD、CommonJS 等模块化规范
但是，这些由社区提出的模块化标准，还是存在一定的差异性与局限性、并不是浏览器与服务器通用的模块化标准

- AMD 和 CMD 适用于浏览器端的 Javascript 模块化(已经被淘汰)
- CommonJS 适用于服务器端的 Javascript 模块化(逐渐会被淘汰)

太多的模块化规范给开发者增加了**学习的难度与开发的成本**。因此，大一统的 ES6 模块化规范诞生了！

**ES6 模块化规范**是**浏览器端**与**服务器**端通用的模块化开发规范。它的出现极大的降低了前端开发者的模块化学习成本，开发者不需再额外学习 AMD、CMD 或 CommonJS 等模块化规范

ES6 模块化规范中定义：

- 每个 js 文件都是一个独立的模块
- 导入其它模块成员使用 **import** 关键字
- 向外共享模块成员使用 **export** 关键字

### 如何在 node.js 中体验 ES6 模块化

node.js 中默认仅支持 CommonJS 模块化规范，若想基于 node.js 体验与学习 ES6 的模块化语法，可以按照如下两个步骤进行配置：
① 确保安装了 v14.15.1 或更高版本的 node.js `node -v`
② 在 package.json（`npm i -y`）的根节点中添加 "type": "module" 节点

ES6 的模块化主要包含如下 3 种用法：
① 默认导出与默认导入
② 按需导出与按需导入
③ 直接导入并执行模块中的代码

### 默认导出与默认导入

export default {变量,方法} // 导出了一个对象,把需要导出的内容挂载成对象成员
import 接收名称 from '模块' // 导入了一个对象

注意事项：

- 每个模块中，只允许使用唯一的一次 export default，否则会报错！
- 默认导入时的接收名称可以任意名称，只要是合法的成员名称即可：

### 按需导出与按需导入

export let s1 = 'aaa'
export let s2 = 'bbb'
export function say(){}
import {s1,s2,say} from '模块' // 按需导入要用花括号把需要导入的项包裹起来作为对象整体导入

注意事项

- 每个模块中可以使用多次按需导出
- 按需导入的成员名称必须和按需导出的名称保持一致 (变量名/方法名)
- 按需导入时，可以使用 **as 关键字进行重命名** `import {s1,s2 as str2,say} from '模块'`
- **默认导出的对象中的成员不可以按需导入，只能把这个对象整体导入**
- 按需导出和默认导出可以一起使用`export default {}` `export let a = 0`
- 这时，按需导入可以和默认导入一起使用 `import info, {s1,s2,say} from '模块'`

### 直接导入并执行模块中的代码

如果只想单纯地执行某个模块中的代码，并不需要得到模块中向外共享的成员。此时，可以直接导入并执行模块代码`import '模块'`

```js
// b.js
let i = 100
export let j = console.log(i)

// a.js
import './b.js' // 直接会打印 100
```

## CommonJS 模块化

- Node 是 CommonJS 在服务器端一个具有代表性的实现
- Browserify 是 CommonJS 在浏览器中的一种实现
- webpack 打包工具具备对 CommonJS 的支持和转换

在 Node 中每一个 js 文件都是一个单独的模块，
exports 和 module.exports 可以负责对模块中的内容进行导出，
require 函数可以帮助我们导入其他模块（内置模块、自定义模块、第三方库模块）。

### 基本用法

使用时，`package.json`中不能有`"type": "module"`

```js
// foo.js
const name = 'zs'
const age = 18
const height = 1.88

//导出方式一：
module.exports = {
  name,
  age,
  height,
}

//导出方式二：
exports.name = name
exports.age = age
exports.height = height

// index.js
const { name, age, height } = require('./foo.js') // require 可以省略`.js`
console.log(name, age, height) // zs 18 1.88
```

### 模块作用域

和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域

好处:
防止了全局变量污染的问题.即使是用 var 定义的变量,也只能在当前模块内被访问

### module 对象

在每个 .js 自定义模块中都有一个 module 对象，它里面存储了和当前模块有关的信息,
可以直接通过`console.log(module)`打印出来

```js
Module {
  id: '.',
  path: 'C:\\Users\\gyhyf\\Desktop\\test',
  exports: {},
  filename: 'C:\\Users\\gyhyf\\Desktop\\test\\a.js',
  loaded: false,
  children: [
    Module {
      id: 'C:\\Users\\gyhyf\\Desktop\\test\\b.js',
      path: 'C:\\Users\\gyhyf\\Desktop\\test',
      exports: [Object],
      filename: 'C:\\Users\\gyhyf\\Desktop\\test\\b.js',
      loaded: true,
      children: [],
      paths: [Array]
    }
  ],
  paths: [
    'C:\\Users\\gyhyf\\Desktop\\test\\node_modules',
    'C:\\Users\\gyhyf\\Desktop\\node_modules',
    'C:\\Users\\gyhyf\\node_modules',
    'C:\\Users\\node_modules',
    'C:\\node_modules'
  ]
}
```

### module.exports 对象

module 变量是一个对象，它的 exports 属性（即 **module.exports**）**是对外的接口**。
在自定义模块中，可以使用 module.exports 对象，将模块内的成员共享出去，供外界使用。
外界用 `require()` 方法导入自定义模块时，得到的就是 module.exports 所指向的对象

一个自定义模块中，默认情况下， `module.exports = {}`, 外界导入的就会是一个空对象
可以用`module.exports.xxx`挂载属性和方法

使用 require() 方法导入模块时，导入的结果，**永远以 module.exports 指向的对象为准**。

1. 会覆盖屏蔽之前挂载的属性和方法
   因为之前的挂载相当于创建了一个对象，后来又用大括号重新创建了一个对象
2. 但不会覆盖之后挂载的属性和方法
   因为之后的挂载相当于给已经存在的 module.exports 对象修改属性和方法

### exports 对象

默认情况下，exports 和 module.exports **指向同一个**对象
**但是**，指向关系会被修改，比如重新对 exports 创建新对象，他们就不再指向同一个对象
由于 module.exports 单词写起来比较复杂，为了简化向外共享成员的代码，Node 提供了 exports 对象，辅助 module.exports 添加内容的。
最终共享的结果，还是以 module.exports 指向的对象为准

**时刻谨记，require() 模块时，得到的永远是 module.exports 指向的对象**
**为了防止混乱，建议大家不要在同一个模块中同时使用 exports 和 module.exports**
