# 构造函数

## 创建构造函数

```js
function Point(x, y) {
  this.x = x
  this.y = y
}
```

## 给构造函数添加成员

### 方法一：在构造函数内部添加

```js
function Point(x, y) {
  this.x = x
  this.y = y
  this.print = function () {
    console.log(this.x, this.y) // 一定要用`this.`
  }
}
```

### 方法二：挂载在构造函数 prototype 上

```js
function Point(x, y) {
  this.x = x
  this.y = y
}
Point.prototype.print = function () {
  console.log(this.x, this.y) // 一定要用`this.`
}
```

### 方法三：在构造函数上添加静态成员

静态成员只有构造函数能访问到，实例无法访问到

```js
function Point(x, y) {
  this.x = x
  this.y = y
}
Point.z = 0

let p = new Point(3, 6)
console.log(p) // Point { x: 3, y: 6 }
console.log(Point.z) // 0
```

## 使用构造函数

通过 new 关键字：

1. 在内存中创建一个新的内存空间
2. 让 this 指向这个新对象
3. 执行构造函数里面的代码，给这个新对象添加属性和方法
4. 返回新对象（所以构造函数不需要 return）

## 构造函数的原型：`prototype`（原型对象）

每一个构造函数都有一个原型对象 prototype，
prototype 里面有构造函数挂载到 prototype 上的公有方法，还有一个 constructor（用于指回该构造函数）；
这个 prototype 原型对象指向另一个原型对象（Object 原型对象 prototype）（因为只要是对象就有`__proto__`,而`__proto__`都指向某个 prototype）

## 实例对象的原型：`__proto__`（对象原型）

每一个对象身上都有`__proto__`，虚拟的，实际上是指向构造函数原型的一个路线，也就是说对象的`__proto__`和他所指向的 prototype 的内容是一致的，因为`__proto__`就指向该 prototype

## JS 成员查找规则

当访问一个对象的属性或方法时：
先在该实例对象身上查找（即构造函数身上）
若没有再查找它的原型对象 prototype
若没有查找原型对象的原型对象（Object 的原型对象）（通过该原型对象的`__proto__`）
若都有，则采取就近原则选择
