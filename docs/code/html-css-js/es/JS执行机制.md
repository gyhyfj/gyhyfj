# JS 执行机制

## 同步任务和异步任务

JavaScript 是一门**单线程执行**的编程语言。也就是说，同一时间只能做一件事情

为了防止某个耗时任务导致程序假死的问题，JavaScript 把待执行的任务分为了两类：

1. 同步任务（synchronous）

   - 又叫做**非耗时任务**，指的是在主线程上排队执行的那些任务
   - 只有前一个任务执行完毕，才能执行后一个任务

2. 异步任务（asynchronous）
   - 又叫做**耗时任务**，异步任务由 JavaScript **委托给宿主环境**进行执行
   - 当异**步任务执行完成后**，会通知 JavaScript **主线程执行**异步任务的**回调函数**

同步任务和异步任务的执行过程
三个位置: 主线程执行栈 宿主环境 任务队列

1. 同步任务由 JavaScript 主线程次序执行
2. 异步任务委托给宿主环境执行
3. 已完成的异步任务对应的**回调函数**，**会被加入**到**任务队列**中等待执行.
4. JavaScript 主线程的**执行栈**被**清空后**，会读取任务队列中的回调函数，次序执行
5. JavaScript 主线程不断重复上面的第 4 步

例如,`thenFs.readFile('./files/3.txt', 'utf8').then(()=>console.log('A'))`, 这个语句,先被放入宿主环境,读取文件结束后,把回调函数`console.log('A')`放回任务队列等待执行
例如,计时器函数,计时结束后会把回调函数放回任务队列等待执行

**JavaScript 主线程从“任务队列”中读取异步任务的回调函数，放到执行栈中依次执行**。这个过程是循环不断的，所以整个的这种运行机制又称为 **EventLoop**（事件循环）

## 宏任务和微任务

JavaScript 把**异步任务又做了进一步的划分**，异步任务又分为两类，分别是：

1. 宏任务（macrotask）

   - 异步 Ajax 请求、
   - setTimeout、setInterval、
   - 文件操作
   - 其它宏任务

2. 微任务（microtask）
   - Promise.then、.catch 和 .finally
   - process.nextTick
   - 其它微任务

每一个宏任务执行完之后，先检查**是否存在待执行的微任务**，
**如果有**，则**执行完所有微任务之后，再继续执行下一个宏任务**。

js 先执行所有同步任务 再执行微任务 再执行下一个宏任务
其中`new Promise(function(){})`,Promise 实例中的函数都是作为同步任务执行

**分析执行顺序的方法**, 只需要思考 同步任务栈 宏任务队列 微任务队列 回调函数队列即可
