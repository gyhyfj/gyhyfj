# 自定义指令

除了 Vue 内置的一系列指令 (比如 v-model 或 v-show) 之外，Vue 还允许你注册自定义的指令。
自定义指令主要是为了重用涉及普通元素的底层 DOM 访问的逻辑。

一个自定义指令被定义为一个包含类似于组件的生命周期钩子的对象

## 基本用法

引入 Directive，
自定义一个类型为 Directive 的 v 开头特定形式的变量，指向一个对象，里面每一项对应生命周期函数的 api
使用时用`v-`的小写形式，可以带参数、赋值等

```ts
const myDirective: Directive = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode, prevVnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount() {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted() {},
  // 绑定元素的父组件更新前调用
  beforeUpdate() {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated() {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount() {},
  // 绑定元素的父组件卸载后调用
  unmounted() {},
}
```

其中：
el：指令绑定到的元素。这可以用于直接操作 DOM。
binding：一个对象，包含以下 property：

1. value：传递给指令的值，例如在 v-my-directive="1 + 1" 中，值是 2。
2. oldValue：之前的值
3. arg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 "foo"。
4. modifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。
5. instance：使用该指令的组件实例。
6. dir：指令的定义对象。

注意：
除了 el 外，你应该将这些参数都视为只读的，并一律不更改它们

可以**对 el 进行 dom 操作**，用到其他参数的值

## 简写

对于自定义指令来说，需要在 mounted 和 updated 上实现相同的行为、又并不关心其他钩子的情况很常见。

下面例子中的正方形会随输入框中输入颜色的改变而改变

```vue
<!-- A.vue -->
<template>
  <div style="width:300px; height:300px"></div>
</template>
```

```vue
<!-- App.vue -->
<script lang="ts" setup>
import { ref, Directive, DirectiveBinding } from 'vue'
import A from './components/A/A.vue'

let value = ref<string>('')
type Dir = {
  background: string
}

const vMove: Directive = (el: HTMLElement, binding: DirectiveBinding) => {
  el.style.background = binding.value.background
}
</script>

<template>
  <input type="text" v-model="value" />
  <A v-move:arg.xxx="{ background: value }" />
</template>
```

## 案例：拖拽效果

```vue
<!-- A.vue -->
<template>
  <div></div>
</template>

<style scoped>
div {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 100px;
  height: 100px;
  background: pink;
}
</style>
```

```vue
<!-- App.vue -->
<script lang="ts" setup>
import { Directive, DirectiveBinding } from 'vue'
import A from './components/A/A.vue'

const vMove: Directive = (el: HTMLElement, binding: DirectiveBinding) => {
  const mouseDown = (e: MouseEvent) => {
    let x = e.clientX - el.offsetLeft
    let y = e.clientY - el.offsetTop
    const mouseMove = (e: MouseEvent) => {
      console.log(e)
      el.style.left = e.clientX - x + 'px' // A 是绝对定位
      el.style.top = e.clientY - y + 'px'
    }
    document.addEventListener('mousemove', mouseMove)
    document.addEventListener('mouseup', () => {
      document.removeEventListener('mousemove', mouseMove)
    })
  }
  el.addEventListener('mousedown', mouseDown)
}
</script>

<template>
  <A v-move />
</template>
```
