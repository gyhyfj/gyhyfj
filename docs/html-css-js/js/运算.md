# 运算

## `+ - * / %`

%是取余 `9 % 2 = 1` `2 % 9 = 2`

小数和整数相乘，可能会出现异常
浮点数值得最高精度是 17 位小数，但在进行算数运算时其精度远远不如整数，尽量避免小数进行算数运算。

```js
console.log(0.0023 * 100) // 0.22999999999999998
console.log(15 * 0.00001) // 0.00015000000000000001
console.log(15 / 10000) // 0.0015
```

`+` 运算只要有一个操作子是字符串，就借助类型转换进行字符串拼接运算
除了 `+` 以外的运算，只要一方是数字，就进行数字运算

## `++ --`

`p++`先返回后自增 `++p`先自增后返回

## `== != === !==`

`===`（全等） `!==`（不全等）
`!=` 与 `!==` ，为 `==` 和 `===` 对应运算的非运算

如果操作数的类型不同，`==` 运算符会在比较之前尝试将它们转换为相同的类型

```js
let a = 1
let b = '1'
let c = '1'
console.log(a == b) // true
console.log(a == c) // true 先临时类型转换后比较
console.log(a === b) // false
console.log(b === c) // true 两个相同字符串指向内存中同一片区域
console.log(a != b) // false 其实就是!(a==b)
console.log(a !== b) // true 其实就是!(a===b)

console.log(+0 === -0) // true

let m = new Object({
  x: 1,
  y: 1,
})
let n = new Object({
  x: 1,
  y: 1,
})
console.log(m === n) // false // m 和 n 指向内存中两片区域

let x = {
  x: 1,
  y: 1,
}
let y = x
console.log(x === y) // true
y.x = 2
console.log(x.x) // 2 // x 和 y 指向内存中同一片区域

console.log(undefined == false) // false
console.log(null == false) // false

console.log(!undefined) // true
console.log(!null) // true
console.log(!NaN) // true
console.log(!0) // true
console.log(!'') // true
```

### `==`运算的判断流程：

1. 首先判断两者类型是否相同，相同就进行比较
2. 类型不相同就进行类型转换
3. 先判断是否在对比 null 和 undefined，是就返回 true
4. 再判断是否在对比 string 和 number，是就把 string 转为 number
5. 判断一方是否是 boolean，是就把 boolean 转为 number（true->1，false->0）
6. 判断其中一方是否是 object 且另一方是 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断（1==[1]） // TODO

### Object.is(v1, v2) 和 ===

使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，
但它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的

## `&& || !`

这些运算会先把操作数转为布尔类型，然后判断是否短路
`a && b && c` 找假，找到就短路，返回假的，找不到返回最后一个
`a || b || c` 找真，找到就短路，返回真的，找不到返回最后一个
JS 中的真假判断，不是一定要是布尔值 `== false`
**断路后，右边剩下的表达式不再执行**
**与运算优先级比或运算高, 但这种优先级只体现在结合性，计算时仍从左到右**

```js
function printA() {
  console.log('A')
}

function printB() {
  console.log('B')
}

console.log(NaN && printA() && printB()) // NaN
console.log(printA() && printB() && 9) // A undefined
console.log(true || (printA() && printB())) // true
console.log(false || (true && printB())) // B undefined
```

## `& | ^ ~ << >> >>>`

JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。
在执行位运算之前，JavaScript 将数字转换为 32 位有符号整数。
执行按位操作后，结果将转换回 64 位 JavaScript 数
只支持对 Number 类型进行位运算

```js
/* n ^ m ^ m = n */
a = 72
b = 3
a = a ^ b
b = a ^ b
a = a ^ b
console.log(`a = ${a}, b = ${b}`) // a = 3, b = 72

a = NaN
b = 3
a = a ^ b
b = a ^ b
a = a ^ b
console.log(`a = ${a}, b = ${b}`) // a = 3, b = 0
```

## `= += -= *= /= %=`

```js
let a = 2,
  b = 3
a /= b // a = a / b  0.66666
a %= b // a = a % b  2
```

```js
let a,
  b,
  c,
  d = 10
a = b = c = d -= 1 // a b c d 都是9
```

## `...`拓展运算符

对象拓展运算：
let obj = {...obj1，obj2}与 Object.assign({},{})类似，若后面的对象与前面的对象有同名属性，则后面的覆盖前面的

数组拓展运算：
数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。

但是 如果数组是 null 的话 会报错
所以拿到后端返回的数组，要加一道判断

另外 数组的解构与对象的解构：

```js
let arr = [1, 2, 3]
let [a, b, c] = arr
let [, , c] = arr


const school = {
   classes: {
      stu: {
         name: 'Bob',
         age: 24,
      }
   }
}                                                                             const { classes: { stu: { name } }} = school
```

## 运算优先级

1. 小括号 `()`
2. 单目运算符 `++ -- !`
3. 算数运算符（先乘除后加减）`+ - * /`
4. 关系运算符 `> >= < <=`
5. 相等运算符 `== === != !==`
6. 逻辑运算符（先与后或） `&& ||`
7. 赋值运算符 `=`
8. 逗号运算符 `,`

::: tip
取地址运算高于取反运算
:::

## ?. ?. ??

逻辑空赋值运算符 (x ??= y) 仅在 x 是 nullish (null 或 undefined) 时对其赋值

```js
let item = {
  name: '',
}

item.children // undefined
item.children.length // typeerr: cannot read properties of undefined (reading 'length')
item.children?.length // undefined
item.children?.length ?? [] // []
null ?? 0 // 0
```

## 可选链操作符`?.`

可选链操作符允许读取位于连接对象链深处的属性的值，而不必明确验证链中的每个引用是否有效。
在引用为空(null 或者 undefined) 的情况下不会引起错误，该表达式短路返回值。
语法：`obj?.prop obj?.[expr] arr?.[index] func?.(args)`

## 空值合并操作符`??`

空值合并操作符是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。
与逻辑或运算不同之处在于，不对`假值（例如 0或''）`响应
空值合并操作符可以在使用可选链时设置一个默认值`customer?.city ?? "CFZ"`

## 空值赋值运算符`??=`

当??=左侧的值为 null、undefined 的时候，才会将右侧变量的值赋值给左侧变量

## 非空断言操作符`!.`

这是 TypeScript 的语法，和`?.`相反，这个符号表示对象后面的属性一定不是 null 或 undefined
`console.log(username!.trim())`
