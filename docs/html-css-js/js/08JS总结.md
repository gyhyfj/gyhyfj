# JS 总结

## 数组的原生方法

toString()、toLocalString()、join()
pop() 和 push()，push 方法可以传入多个参数
shift() 和 unshift() unshift 方法可以传递多个参数，表示在数组开头增加
reverse() 和 sort()，都改变原数组
reverse()是把数组顺序颠倒
sort() 方法可以传入一个函数来进行比较，传入前后两个值，比如是 x 和 y，返回一个数字，如果数字小于 0，则 x 在 y 前面，如果数字大于 0，则 x 在 y 后面。默认是升序
concat() ，返回的是拼接好的数组，不影响原数组
slice(begin [ end ])，用于截取数组中的一部分返回，不影响原数组。
array.splice(start[, deleteCount[, item1[, item2[, ...]]]])，改变原数组
reduce() 和 reduceRight() 方法 （数组归并）

## use strict

是 ES5 添加的严格模式
禁止使用 with 语句 禁止 this 指向全局对象 对象不能有重名的属性
目的：
提高编译器效率，增加运行速度
消除 Javascript 语法的不合理、不严谨之处，减少怪异行为
消除代码运行的不安全之处，保证代码运行的安全
为未来新版本的 Javascript 做好铺垫

## for in 和 for of 的区别

for...in 是为遍历对象属性而构建的
for...in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for...of 只遍历当前对象不会遍历原型链
对于数组的遍历，for...in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for...of 只返回数组的下标对应的属性值

```js
var triangle = { a: 1, b: 2, c: 3 }

function ColoredTriangle() {
  this.color = 'red'
}

ColoredTriangle.prototype = triangle

var obj = new ColoredTriangle()

for (var prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`)
  }
}

// Output:
// "obj.color = red"
```

## 数组的遍历方法：

for...of 不改变原数组
forEach() 视情况是否改变原数组
filter() 不改变原数组，有返回值，返回一个符合筛选规则的新数组
every() 和 some() 不改变原数组，some()只要有一个是 true，便返回 true；而 every()只要有一个是 false，便返回 false.
map() 不改变原数组 数组方法，不改变原数组，有返回值，生成一个一一对应的新数组
find() 和 findIndex() 不改变原数组，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值
reduce() 和 reduceRight() 不改变原数组，reduce()对数组正序操作；reduceRight()对数组逆序操作

## forEach 和 map 方法有什么区别

forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值
map()方法不会改变原数组的值，有返回值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值

## 实现深拷贝的方法

JSON.stringify()
函数库 lodash 的`_.cloneDeep` 方法
手写实现深拷贝函数

```js
function deepCopy(obj) {
  if (!obj || typeof obj !== 'object') return
  let newObj = Array.isArray(obj) ? [] : {}
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = typeof obj[key] === 'object' ? deepCopy(obj[key]) : obj[key]
    }
  }
  return newObj
}
```

## 浏览器的垃圾回收机制

当变量不再参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。
Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放。
全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。
当局部变量被外部函数使用时，其中一种情况就是**闭包**，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。

垃圾回收的方式：
标记清除：
当变量出入执行环境时，会加上标记。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。在此之后再被加上标记的变量将被视为准备删除的变量。
引用计数：
引用计数就是跟踪记录每个值被引用的次数，当这个引用次数变为 0 时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。但这种方法会引起循环引用的问题。

应尽量减少垃圾回收，主动释放内存：
数组：清空数组时，可以将数组的长度设置为 0，以此来达到清空数组的目的
对象：对于不再使用的对象，就将其设置为 null，尽快被回收
函数：在循环中的函数表达式，如果可以复用，尽量放在函数的外面

内存泄露：
无法垃圾回收就是内存泄露

1. 意外的全局变量（使用未声明的变量，而意外的创建了一个全局变量，无法被回收）
2. 被遗忘的计时器或回调函数
3. 脱离 DOM 的引用（获取一个 DOM 元素的引用，而后面这个元素被删除，但这个引用一直都在）
4. 闭包（不合理的使用闭包，从而导致某些变量一直被留在内存当中）

## 防抖和节流

函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时
场景：
按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次
服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能

函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效
场景：
拖拽 缩放 滚动 滑动

实现：
防抖：

```js
function debounce(fn, wait) {
  let timer = null
  // 返回了一个匿名函数作为事件的回调函数
  return function (...rest) {
    let context = this

    /* 如果存在定时器 */
    if (timer) {
      clearTimeout(timer)
      timer = null
    }

    timer = setTimeout(() => {
      fn.apply(context, rest)
    }, wait)
  }
}
```

节流：

```js
function throttle(fn, delay) {
  let preTime = Date.now()
  return function (...rest) {
    let context = this
    nowTime = Date.now()
    if (nowTime - preTime >= delay) {
      preTime = Date.now()
      return fn.apply(context, args)
    }
  }
}
// 或
function throttle(fn, delay) {
  let timeout = null
  return function (...rest) {
    let context = this
    if (!timeout) {
      timeout = setTimeout(() => {
        fn.apply(context, rest)
        timeout = null
      }, delay)
    }
  }
}
```

## 判断对象是否为空

1. JSON.stringify 不行，因为会把`{a:()=>{}}`也转为`{}`

   ```js
   let a = {
     x: () => {},
   }
   console.log(JSON.stringify(a)) // {}
   ```

2. Object.keys()方法可以，返回一个属性的数组，判断数组长度是否为 0
3. for in 有时不行，因为 for in 会遍历整个原型链，需要用 hasOwnProperty()方法过滤掉
4. Object.getOwnPropertyNames()方法，返回一个由指定对象的所有自身属性的属性名组成的数组，判断是否长度为 0

这些方法遇到 Symbol 值作为名称的属性，或不可枚举属性，很可能会出问题

```js
let a = {
  [Symbol()]: 'hi',
}
console.log(a) // { [Symbol()]: 'hi' }
console.log(Object.keys(a)) // []
```

## 函数

嵌套在内部的函数，定义和调用都可以使用外面环境中的参数
