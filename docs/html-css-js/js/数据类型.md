# 数据类型

## 变量

变量是程序在内存中申请的一块用来存放数据的空间
变量名由大小写字母、数字、下划线和`$`组成，不能以数字开头,**变量名不能用`-`符**

```js
/* 只声明不赋值 */
let a
console.log(a) // undefined

/* 重复声明且重复赋值 */
let a = 2
let a = 3
console.log(a) // 3

/* 重复声明但不重复赋值, 原值不会被覆盖 */
let a = 2
let a
console.log(a) // 2

/* 不声明直接赋值，不报错 */
a = 3
console.log(a) //3
```

### let const var 的区别

let 和 const 具有块级作用域
var 可以变量提升（但也只是定义提升了，赋值不提升）
var 能重复声明变量
var 不存在暂时性死区（变量声明前不能使用） `var a = a // undefined`
const 定义的值或指向不能修改，所以必须设置初始值
const 的指针指向不能修改

```js
for (let i = 0; i < 5; i++) {
  console.log(i) // 0 1 2 3 4 能访问到 i
}
console.log(i) // err, i is not defined
```

```js
for (var i = 0; i < 5; i++) {
  console.log(i) // 0 1 2 3 4 能访问到 i
}
console.log(i) // 5
```

## 数据类型的区别

基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储

引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体

总结：
基本数据类型存储在栈内存中，引用数据类型存储在堆内存中
数据存储时，基本数据类型在变量中存的是值，引用数据类型在变量中存储的是空间地址
基本数据操作的是值，引用数据类型操作的是空间地址

## 数据类型检测

1. typeof xxx
   返回字符串

   ```js
   typeof undefined // undefined
   typeof null // object
   typeof ()=>{} // function
   ```

2. xxx instanceof constructor
   用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上
   难以判断一些基础数据类型
   返回 true 或 false

   ```js
   2 instanceof Number // false
   true instanceof Boolean // false
   'str' instanceof String // false
   [] instanceof Array // true
   (()=>{}) instanceof Function // true
   {} instanceof Object // true

   let str = 'str'
   str instanceof String // false

   let str = new String('str')
   str instanceof String // true
   ```

3. Object.prototype.toString.call(xxx)
   返回字符串`'[object 数据类型]'`

   ```js
   Object.prototype.toString.call(1) // [object Number]
   Object.prototype.toString.call(undefined) // [object Undefined]
   Object.prototype.toString.call(null) // [object Null]
   Object.prototype.toString.call(/abc/g) // [object RegExp]
   Object.prototype.toString.call(new Date()) // [object Date]
   ```

## 6 种基本数据类型

## 1. Number（数字型）

JS 的 Number 类型不区分整型和浮点型
数字范围：Number.MIN_VALUE 到 Number.MAX_VALUE
三个特殊值：Infinity、 -Infinity、 NaN（非数值）

```js
console.log(Number.MAX_VALUE) // 1.7976931348623157e+308
console.log(Number.MIN_VALUE) // 5e-324

let a = Infinity
console.log(a) // Infinity

let a = -Infinity
console.log(a) // -Infinity

let a = 0 / 0
console.log(a) // NaN
console.log(isNaN(a)) // true
```

其中只有 NaN 非自反，即`NaN!=NaN`
但是 `Object.is(v1, v2)` 判断两个 NaN 是相等的

### isNaN 和 Number.isNaN

函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。

函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。

```js
isNaN('NaN') // true
Number.isNaN('NaN') // false
```

## 2. String（字符串型）

JS 的 String 不区分字符型和字符串型
用`'`或`"`或`` ` ``（支持多行字符）包裹
JSON 解析字符串时，一定是内双外单

```js
a = JSON.parse('["abc"]')
console.log(a) // ['abc']
```

一样的 string 指向同一片内存空间
new String()构造器生成的数据类型不是 string，而是对象

```js
let str1 = 'abc'
let str2 = 'abc'
console.log(str1 === str2) // true
let str3 = new String('abc')
console.log(typeof str3) // object
console.log(str3) // [String: 'abc']
```

### str[index]

返回索引处的字符，index 不合法则返回`undefined`

### str.indexOf(searchValue [, fromIndex])

查找字符子串并返回索引位置，没有返回-1

```js
let str = 'this is a book'
str.indexOf('is') // 2
str.indexOf('is', 3) // 5 第二个参数是起始索引，起始索引为空或为负数，规范化为0；起始索引超出字符串范围，规范化为字符串长度-1
str.indexOf('', 9) // 9 查询字符串为空字符串，则返回规范化后的起始索引
```

### str.charAt() 和 str.charCodeAt()

str.charAt() 返回字符串在某个索引处的字符，不在字符串范围内则返回`''`
str.charCodeAt() 方法返回 0 到 65535 之间的整数，表示给定索引处的 UTF-16 代码单元。不存在则返回`NaN`

```js
let str = 'this is a book'

str.charAt(0) // 't'
str.charAt(100) // ''
str.charAt(-1) // ''

str.charCodeAt(1) // 104
str.charCodeAt(100) // NaN
str.charCodeAt(-1) // NaN
```

### str.concat(str1[, str2, str3])

拼接多个字符串，等同于`+`

### str.substring(indexStart[, indexEnd])

提取从 indexStart 到 indexEnd（不包括）之间的字符
如果两个参数相等，则返回空字符串 `''`
如果省略 indexEnd，substring 提取字符一直到字符串末尾
如果任一参数小于 0 或为 NaN，则被当作 0
如果 indexStart 大于 indexEnd，则 substring 执行时自动调换两个参数

### str.slice(start, end)

从索引为 start 处截取到索引为 end 处。（end 处截取不到）

### str.replace(regexp|substr, newSubStr|function)

把 str 中的前者替换为后者。如果是 substr 则只对匹配到的第一个执行
function 是一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果

### str.trim()

trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR 等）。

### str.split([separator[, limit]])

```js
let str = 'this is a book'
str.split('a') // [ 'this is ', ' book' ]
str.split(' ') // [ 'this', 'is', 'a', 'book' ]
str.split('') // [ 't', 'h', 'i', 's', ' ', 'i', 's', ' ', 'a', ' ', 'b', 'o', 'o', 'k' ]
str.split() // [ 'this is a book' ]
```

// TODO 用数组分割字符串

## 3. Boolean（布尔型）

true 和 false

## 4. Null（void 型）

基本数据类型，只有一个值 null
一些方法获取不到结果的返回值
可以给变量赋值为 null，来清空变量，可以用来释放堆内存

## 5. Undefined（void 型）

基本数据类型，只有一个值 undefined
安全获取 undefined：`console.log(void 0) // undefined`

1. 变量只声明未赋值，值为 undefined
2. 对象的属性不存在，获取的值为 undefined
3. 函数的形参没传入实参，值为 undefined
4. 函数没有返回值，返回 undefined
5. 超出数组范围的引用，返回 undefined

```js
let a = 0
console.log(console.log(a)) // 0 undefined
```

## 6. Symbol

Symbol() 函数会返回 symbol 类型的值，该类型具有静态属性和静态方法。
每个从 Symbol() 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol

```js
let a = Symbol('1')
console.log(a) // Symbol(1)
console.log(a == '1') // false

Symbol('bar') === Symbol('bar') // false，Symbol() 函数每次都会返回新的一个 symbol
```

Symbol.for(key) 方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。

```js
/*
 * 第一个for方法：创建一个 symbol 并放入 symbol 注册表中，键为 "foo"
 * 第二个for方法：从 symbol 注册表中读取键为"foo"的 symbol
 */
Symbol.for('bar') === Symbol.for('bar') // true
```

## 8 种引用数据类型/复杂数据类型

统称为 Object

## 1. Array（数组）

JS 数组可以混合存放任意类型的变量
可以用 new 方法创建，也可以用字面量创建

```js
let a = new Array() // []
let a = [] // []

let a = [1, 2]
a[3] = 6 // [ 1, 2, <1 empty item>, 6 ]
```

### 判断是否为数组

4 种方法

```js
let a = [1, 2, 3]

a instanceof Array // true
Object.prototype.toString.call(a) // [object Array] 是一个字符串
a.__proto__ === Array.prototype // true
Array.prototype.isPrototypeOf(a) // true

typeof a // object，不行
```

### arr.push(item)，arr.unshift(item)

一个在数组末尾添加，一个在数组开头添加。和 String 的方法不同，都改变了原数组

### arr.pop()，arr.shift()

一个在数组末尾删除，一个在数组开头删除。这两个都改变原数组。这两个都不接收参数

### arr.splice(start[, deleteCount[, item1[, item2[, ...]]]])

splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。
start 指定开始修改的位置
deleteCount 指定删除的数量
item 是要添加进数组的元素

**连用 splice 会出 bug!!!**

```js
let arr = [0, 1, 2, 3]

let tmp = arr[2]
// arr.splice(2, 1).splice(1, 0, tmp) // [ 0, 1, 3 ]
arr.splice(2, 1)
arr.splice(1, 0, tmp) // [ 0, 2, 1, 3 ]
console.log(arr)
```

### arr.sort()，arr.reverse()

一个对数组进行排序，一个颠倒数组原来的顺序
sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值

```js
const arr = [1, 30, 4, 21, 100000]
arr.sort()
console.log(arr) // [1, 100000, 21, 30, 4]
```

sort()可以接收一个 compareFunction 作为参数：
如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前。
如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。
如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。

```js
/* 定义两元素间的比较规则 */
function compare(a, b) {
  if (a < b) {
    // 按某种排序标准进行比较，a 小于 b，返回小于0的数，导致 a 排在 b 前面
    return -1
  }
  if (a > b) {
    return 1
  }
  // a must be equal to b
  return 0
}

/* 等同于如下的比较规则 */
function compare(a, b) {
  return a - b
}
```

### arr.indexOf(item)，arr.lastIndexOf(item)

一个查找给定元素的索引，一个查找给定元素最后一次出现的索引
如果存在则返回索引，不存在则返回`-1`

### arr.toString()，arr.join(str)

一个把数组转为字符串，用逗号分隔每一项，一个是把数组转为字符串，用 str 分隔每一项。str 不写则默认为逗号
arr.toString()等同于 arr.join()

### arr.slice()

// TODO

### arr.concat()，[...arr1, arr2]

### arr.indexOf(item, indexStart)

### arr.lastIndexOf(item, indexStart)

### arr.forEach()

forEach() 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。
forEach() 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach() 遍历到他们那一刻的值。

```js
arr.forEach(element => {
  /* ... */
})
arr.forEach((element, index) => {
  /* ... */
})
arr.forEach((element, index, array) => {
  /* ... */
})
```

### arr.filter(callback(element[, index[, array]])[, thisArg])

filter() 方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。
回调函数要返回 true 或 false，以表示当前元素是否通过测试。
只有回调函数非箭头函数的形式，this 才能正常指向 thisArg 这个参数。

### arr.map(callback(currentValue[, index[, array]])[, thisArg])

映射出一个新的数组，回调函数返回对应生成的每个新数组的元素

### arr.every(callback(element[, index[, array]])[, thisArg])

every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

### arr.some(callback(element[, index[, array]])[, thisArg])

some() 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。

### arr.reduce()

reduce() 方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后返回最终的那个返回值。
第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 initialValue

```js
let arr = [1, 2, 3, 4]
let initVal = 0
let count = arr.reduce((prev, current) => prev + current, initVal)
console.log(count) // 10
console.log(initVal) // 0
```

## 2. Object（对象）

在 JS 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。对象是由属性和方法组成的。
可以用`new Object()`创建，也可以用字面量创建，也可以也可以自己写一个构造函数，用`new 构造函`数创建

对象中的方法，直接用匿名函数，调用时用`属性名(参数)`

```js
let obj = new Object()
obj.name = 'zs'
obj.age = 14

let obj = {
  name: 'zs',
  age: 14,
}

function Person(name, age) {
  this.name = name
  this.age = age
}
let obj = new Person() // { name: undefined, age: undefined }
let obj = new Person('zs', 14) // { name: 'zs', age: 14 }
```

判断一个对象是否为空

```js
JSON.stringfy(obj) === {}
Object.keys(obj).length === 0
```

### new 与构造函数

new 关键字会进行如下的操作：

1. 创建一个空的简单 JavaScript 对象（即{}）；
2. 为步骤 1 新创建的对象添加属性**proto**，将该属性链接至构造函数的原型对象 ；
3. 将步骤 1 新创建的对象作为 this 的上下文 ；
4. 如果该函数没有返回对象，则返回 this。

构造函数名称首字母通常大写，且内部构造的属性名与方法名之前要加`this.`，调用时要用关键词`new`
一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤

## 3. Function（函数）

函数实际上是一个函数对象，而函数名只是指向这个函数的变量

### arguments 对象

当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。它是函数的内置对象，只在函数内部起作用，存储了传递的所有实参。
arguments 是伪数组，具有 length 长度，按照索方式存储数据，但不具有数组的 pop、push 等方法
可以使用`Array.from()`方法或扩展运算符`...`将参数转换为真实数组：

```js
function func(a, b) {
  console.log(arguments.length)
  console.log(arguments[0])
}
let args = Array.from(arguments)
let args = [...arguments]
```

**如果你编写兼容 ES6 的代码，那么优先推荐使用 剩余参数**

### 剩余参数

剩余参数语法允许我们将一个不定数量的参数表示为一个数组
如果函数的最后一个命名参数以...为前缀，则它将成为一个由剩余参数组成的真数组

```js
function foo(a, b, ...rest) {
  /*
   * 传入的参数先绑定a、b，多余的参数以数组形式交给变量rest
   * rest没接收到参数时，则为一个空数组[]
   */
}
```

arguments 对象不是一个真正的数组，
而剩余参数是真正的 Array 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach 或 pop

### 箭头函数与普通函数的区别

1. 箭头函数比普通函数更加简洁
2. 箭头函数没有自己的 this
   箭头函数不会创建自己的 this， 所以它没有自己的 this，它只会在自己作用域的上一层继承 this。所以箭头函数中 this 的指向在它在定义时已经确定了，之后不会改变。
3. call()、apply()、bind()等方法不能改变箭头函数中 this 的指向
4. 箭头函数不能作为构造函数使用
5. 箭头函数没有自己的 arguments
6. 箭头函数没有 prototype
7. 箭头函数不能用作 Generator 函数，不能使用 yield 关键字

箭头函数不同于传统 JavaScript 中的函数，箭头函数并没有属于⾃⼰的 this，它所谓的 this 是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的 this，所以是不会被 new 调⽤的，这个所谓的 this 也不会被改变。箭头函数的 this 指向外层函数的 this

## 4. Map（映射）

## 5. Set（集合）

## 6. Math（数学）

Math 对象 是一个内置对象，它拥有一些数学相关的属性和方法
Math 的所有属性与方法都是静态的
Math 不是一个函数对象，也不是一个构造器

```js
Math.PI //3.141592653589793

Math.round(3.14) // 3 四舍五入
Math.ceil(3.14) // 4 向上取整
Math.floor(3.14) // 3 向下取整

Math.max(1, 2, 3) // 3 最大值
Math.min(1, 2, 3) // 1 最小值

Math.abs(-1) // 1 绝对值

Math.random() // 生成[0,1)上随机的浮点数

/* 生成[min,max]上的随机整数 */
function getRandomIntInclusive(min, max) {
  min = Math.ceil(min)
  max = Math.floor(max)
  //含最大值，含最小值
  return Math.floor(Math.random() * (max - min + 1)) + min
}
```

// TODO 更多的随机函数

## 7. Date（日期）

### 创建日期对象

`new Date()`是一个构造函数，必须使用 new 来调用创建我们的日期对象。

```js
let date = new Date() // 2022-07-20T00:04:57.850Z
let date = new Date(1996, 9, 1) // 1996-09-30T16:00:00.000Z 月份从0开始，括号中的9表示10月
let date = new Date('2022-7-20 8:8:8') // 2022-07-20T00:08:08.000Z
```

### 创建时间戳（时间戳是数字类型的一个数字）

```js
let date = Date.now() // 1658275529271 时间戳

let date = +new Date() // 1658275529271 时间戳

let date = new Date()
date = date.valueOf() // 1658275529271 时间戳

let date = new Date()
date = date.getTime() // 1658275529271 时间戳
```

### 时间戳转日期

```js
let stamp = Date.now()
let date = new Date(stamp)
console.log(stamp) // 1658278861888
console.log(date) // 2022-07-20T01:01:01.888Z
```

### 格式化日期

格式化日期是针对 Date 对象，而不是时间戳这样的数字类型

```js
let date = new Date('2022-07-20 08:20:30') // 2022-07-20T00:20:30.655Z
date.getFullYear() // 2022
date.getMonth() // 6 // 月份从0开始计，6代表7月
date.getDate() // 20
date.getDay() // 3 // 1到6代表周一到周六，0代表周日
date.getHours() // 8
date.getMinutes() // 20
date.getSeconds() // 30
```

## 8. RegExp（正则表达式）

## 数据类型转换

1. 转为字符串类型
   变量.toString()
   String(变量)
   变量+''

2. 转为数字类型
   Number(变量)

   ```js
   parseInt(变量) // 将 String 类型变量转为整数（不四舍五入，直接去掉小数部分）
   parseFloat(变量) // 将 String 类型变量转为浮点数（保留小数部分）
   ```

3. 转为布尔类型
   Boolean(变量)

   ```js
   Boolean('true') // true
   Boolean('false') // true
   Boolean('0') // true
   Boolean('abc') // true
   Boolean('') // false
   Boolean(null) // false
   Boolean(undefined) // false
   Boolean(NaN) // false
   ```

### 其他值转字符串

1. Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"
2. Boolean 类型，true 转换为 "true"，false 转换为 "false"
3. Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式
4. Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误
5. 对普通对象来说，除非自行定义 `toString()` 方法，否则会调用`Object.prototype.toString()`来返回内部属性 `[[Class]]` 的值，如`"[object Object]"`。如果对象有自己的 `toString()` 方法，字符串化时就会调用该方法并使用其返回值

::: tip
每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。
默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中 type 是对象的类型。
:::

### 其他值转数字

1. Undefined 类型，undefined 转换为 NaN
2. Null 类型，null 转换为 0
3. Boolean 类型的值，true 转换为 1，false 转换为 0
4. String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0
5. Symbol 类型的值不能转换为数字，会报错
6. 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字 `['1']==1 // true`

### 其他值转布尔

`'' +0 -0 NaN undefined null`转 false
其他转 true

## JS 的包装类型

在 JavaScript 中，基本类型是没有属性和方法的，
但是为了便于操作基本类型的值，
在调用基本类型的属性或方法时，JavaScript 会在后台隐式地将基本类型的值转换为对象

例如：
在访问'abc'.length 时，JavaScript 将'abc'在后台转换成 String('abc')，然后再访问其 length 属性。

```js
let a = 'abc'
a.length // 3
a.toUpperCase // "ABC"
```

可以用 Object()显式将基本类型转为包装类型，
可以用包装类型的 valueOf()方法将包装类型转为基本类型

```js
let a = 'abc'
let b = Object(a) // String {a: 'abc'}
let c = b.valueOf() // 'abc'
```
