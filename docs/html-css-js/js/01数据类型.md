# 数据类型

## 变量

变量是程序在内存中申请的一块用来存放数据的空间
变量名由大小写字母、数字、下划线和`$`组成，不能以数字开头,**变量名不能用`-`符**

```js
/* 只声明不赋值 */
let a
console.log(a) // undefined

/* 重复声明且重复赋值 */
let a = 2
let a = 3
console.log(a) // 3

/* 重复声明但不重复赋值, 原值不会被覆盖 */
let a = 2
let a
console.log(a) // 2

/* 不声明直接赋值，不报错 */
a = 3
console.log(a) //3
```

### let const var 的区别

1. let 和 const 具有块级作用域
2. var 可以变量提升（赋值不提升），让函数可以在执行时预先为变量分配栈空间
3. var 不存在暂时性死区（var 变量声明前也能使用，值是 undefined） `var a = a // undefined`
4. var 能重复声明变量，let 和 const 不能
5. const 定义的值或指向不能修改，且必须设置初始值

```js
for (let i = 0; i < 5; i++) {
  console.log(i) // 0 1 2 3 4 能访问到 i
}
console.log(i) // err, i is not defined
```

```js
for (var i = 0; i < 5; i++) {
  console.log(i) // 0 1 2 3 4 能访问到 i
}
console.log(i) // 5
```

## 数据类型的区别

基本数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储

引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体

总结：
基本数据类型存储在栈内存中，引用数据类型存储在堆内存中
数据存储时，基本数据类型在变量中存的是值，引用数据类型在变量中存储的是空间地址
基本数据操作的是值，引用数据类型操作的是空间地址

## 数据类型检测（4 种）

1. typeof xxx
   返回字符串，判断简单数据类型

   ```js
   typeof undefined // undefined
   typeof null // object
   typeof ()=>{} // function
   ```

2. xxx instanceof constructor
   返回 true 或 false
   判断是否是某构造器的实例
   用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

   ```js
   2 instanceof Number // false
   true instanceof Boolean // false
   'str' instanceof String // false
   [] instanceof Array // true
   (()=>{}) instanceof Function // true
   {} instanceof Object // true

   let str = 'str'
   str instanceof String // false

   let str = new String('str')
   str instanceof String // true
   ```

3. Object.prototype.toString.call(xxx)
   返回字符串`'[object 数据类型]'`
   之所以用 call 改变 this 指向，是因为原型链下游的这些对象的 toString 方法被改写了
   所以要对 xxx 执行 Object.prototype.toString 方法，

   ```js
   Object.prototype.toString.call(1) // [object Number]
   Object.prototype.toString.call(undefined) // [object Undefined]
   Object.prototype.toString.call(null) // [object Null]
   Object.prototype.toString.call(/abc/g) // [object RegExp]
   Object.prototype.toString.call(new Date()) // [object Date]
   ```

4. 使用 ES6 的方法
   比如判断一个变量是否为数组

   ```js
   // 1. instanceof
   arr instanceof Array // true
   // 2. Object.prototype.toString.call
   Object.prototype.toString.call(arr) // [object Array]
   // 3. ES6方法 Array.isArray
   Array.isArry(arr) // true
   // 4. 通过原型链判断，看arr的隐式原型是否指向Array的显式原型
   arr.__proto__ === Array.prototype // true
   // 5. 通过原型链判断，看Array是否在arr的原型链上 Array.prototype.isPrototypeOf()
   Array.prototype.isPrototypeOf(arr) // true
   ```

## 基本数据类型

## 1. Number（数字型）

JS 的 Number 类型不区分整型和浮点型
数字范围：Number.MIN_VALUE 到 Number.MAX_VALUE
三个特殊值：Infinity、 -Infinity、 NaN（非数值）

```js
console.log(Number.MAX_VALUE) // 1.7976931348623157e+308
console.log(Number.MIN_VALUE) // 5e-324

let a = Infinity
console.log(a) // Infinity

let a = -Infinity
console.log(a) // -Infinity

let a = 0 / 0
console.log(a) // NaN
console.log(isNaN(a)) // true
```

其中只有 NaN 非自反，即`NaN!=NaN`
但是 `Object.is(v1, v2)` 判断两个 NaN 是相等的

### isNaN 和 Number.isNaN

函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。

函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。

```js
isNaN('NaN') // true
Number.isNaN('NaN') // false
```

## 2. String（字符串型）

JS 的 String 不区分字符型和字符串型
用`'`或`"`或`` ` ``（支持多行字符）包裹
**JSON 解析字符串时，一定是内双外单**

```js
a = JSON.parse('["abc"]')
console.log(a) // ['abc']
```

一样的 string 指向同一片内存空间
new String()构造器生成的数据类型不是 string，而是对象

```js
let str1 = 'abc'
let str2 = 'abc'
console.log(str1 === str2) // true
let str3 = new String('abc')
console.log(typeof str3) // object
console.log(str3) // [String: 'abc']
```

### str[index]

返回索引处的字符，index 不合法则返回`undefined`

### str.indexOf(searchValue [, fromIndex])

查找字符子串并返回索引位置，没有返回-1

```js
let str = 'this is a book'
str.indexOf('is') // 2
str.indexOf('is', 3) // 5 第二个参数是起始索引，起始索引为空或为负数，规范化为0；起始索引超出字符串范围，规范化为字符串长度-1
str.indexOf('', 9) // 9 查询字符串为空字符串，则返回规范化后的起始索引
```

### str.charAt() 和 str.charCodeAt()

str.charAt() 返回字符串在某个索引处的字符，不在字符串范围内则返回`''`
str.charCodeAt() 方法返回 0 到 65535 之间的整数，表示给定索引处的 UTF-16 代码单元。不存在则返回`NaN`

```js
let str = 'this is a book'

str.charAt(0) // 't'
str.charAt(100) // ''
str.charAt(-1) // ''

str.charCodeAt(1) // 104
str.charCodeAt(100) // NaN
str.charCodeAt(-1) // NaN
```

### str.concat(str1[, str2, str3])

拼接多个字符串，等同于`+`

### str.substring(indexStart[, indexEnd])

提取从 indexStart 到 indexEnd（不包括）之间的字符，前闭后开的区间
如果两个参数相等，则返回空字符串 `''`
如果省略 indexEnd，substring 提取字符一直到字符串末尾
如果任一参数小于 0 或为 NaN，则被当作 0
如果 indexStart 大于 indexEnd，则 substring 执行时自动调换两个参数

### str.slice(start, end)

从索引为 start 处截取到索引为 end 处，前闭后开的区间

### str.replace(regexp|substr, newSubStr|function)

把 str 中的前者替换为后者。如果是 substr 则只对匹配到的第一个执行
function 是一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果

### str.trim()

trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR 等）。

### str.split([separator[, limit]])

都返回一个字符串数组，但分 4 种情况：
不传入参数 不分割
传入空字符串 全分割
传入空格 按空格分割
传入字符，按字符分割

```js
let str = 'this is a book'
str.split('a') // [ 'this is ', ' book' ]
str.split(' ') // [ 'this', 'is', 'a', 'book' ]
str.split('') // [ 't', 'h', 'i', 's', ' ', 'i', 's', ' ', 'a', ' ', 'b', 'o', 'o', 'k' ]
str.split() // [ 'this is a book' ]
```

// TODO 用数组分割字符串

## 3. Boolean（布尔型）

true 和 false

## 4. Null

基本数据类型，只有一个值 null
一些方法获取不到结果的返回值
可以给变量赋值为 null，来清空变量，可以用来释放堆内存

## 5. Undefined

基本数据类型，只有一个值 undefined
安全获取 undefined：`console.log(void 0) // undefined`

1. 变量只声明未赋值，值为 undefined
2. 对象的属性不存在，获取的值为 undefined
3. 函数的形参没传入实参，值为 undefined
4. 函数没有返回值，返回 undefined
5. 超出数组范围的引用，返回 undefined

```js
let a = 0
console.log(console.log(a)) // 0 undefined
```

## 6. Symbol

Symbol 类型的变量只能通过 Symbol()构造器生成，该类型具有静态属性和静态方法。
每个从 Symbol() 返回的 symbol 值都是唯一的。一个 symbol 值能作为对象属性的标识符；这是该数据类型仅有的目的。
https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol

```js
let a = Symbol('1')
console.log(a) // Symbol(1)
console.log(a == '1') // false

let b = {
  [a]: 1,
}

Symbol('bar') === Symbol('bar') // false，Symbol() 函数每次都会返回新的一个 symbol
```

Symbol.for(key) 方法会根据给定的键 key，来从运行时的 symbol 注册表中找到对应的 symbol，如果找到了，则返回它，否则，新建一个与该键关联的 symbol，并放入全局 symbol 注册表中。

```js
/*
 * 第一个for方法：创建一个 symbol 并放入 symbol 注册表中，键为 "foo"
 * 第二个for方法：从 symbol 注册表中读取键为"foo"的 symbol
 */
Symbol.for('bar') === Symbol.for('bar') // true
```

## 8 种引用数据类型/复杂数据类型

统称为 Object

## 1. Array（数组）

> 数组方法：
> toString()、toLocalString()、join()
>
> pop() 和 push() push 在数组结尾增加，可以传入多个参数
> shift() 和 unshift() unshift 在数组开头增加，可以传递多个参数
>
> reverse() 和 sort()，都改变原数组
> reverse()是把数组顺序颠倒
> sort() 方法可以传入一个函数来进行比较，传入前后两个值，比如是 x 和 y，返回一个数字，如果数字小于 0，则 x 在 y 前面，如果数字大于 0，则 x 在 y 后面。默认> 是升序
>
> concat() ，返回的是拼接好的数组，不影响原数组，浅拷贝
>
> slice(begin [ end ])，用于截取数组中的一部分返回，不影响原数组，浅拷贝
>
> array.splice(start[, deleteCount[, item1[, item2[, ...]]]])，改变原数组
>
> reduce() 和 reduceRight() 方法 （数组归并）
>
> 数组遍历方法：
> for...of 不改变原数组
> forEach() 视情况是否改变原数组
> filter() 不改变原数组，有返回值，返回一个符合筛选规则的新数组
> every() 和 some() 不改变原数组，some()只要有一个是 true，便返回 true；而 every()只要有一个是 false，便返回 false.
> map() 不改变原数组 数组方法，不改变原数组，有返回值，生成一个一一对应的新数组
> find() 和 findIndex() 不改变原数组，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值
> reduce() 和 reduceRight() 不改变原数组，reduce()对数组正序操作；reduceRight()对数组逆序操作

JS 数组可以混合存放任意类型的变量
可以用 new 方法创建，也可以用字面量创建

```js
let a = new Array() // []
let a = [] // []

let a = [1, 2]
a[3] = 6 // [ 1, 2, <1 empty item>, 6 ]
```

### 判断是否为数组

4 种方法

```js
// 1. instanceof
arr instanceof Array // true
// 2. Object.prototype.toString.call
Object.prototype.toString.call(arr) // [object Array]
// 3. ES6方法 Array.isArray
Array.isArry(arr) // true
// 4. 通过原型链判断，看arr的隐式原型是否指向Array的显式原型
arr.__proto__ === Array.prototype // true
// 5. 通过原型链判断，看Array是否在arr的原型链上 Array.prototype.isPrototypeOf()
Array.prototype.isPrototypeOf(arr) // true
```

### arr.push(item)，arr.pop()，arr.unshift(item)，arr.shift()

在数组末尾添加和删除 arr.push(item)，arr.pop()
在数组开头添加和删除 arr.unshift(item)，arr.shift()

### arr.splice(start[, deleteCount[, item1[, item2[, ...]]]])

splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回被修改的内容。此方法会改变原数组。
第一个参数 指定开始修改的位置
第二个参数 指定要删除的数量
剩余参数 要添加进数组的元素
**连用 splice 会出 bug!!!**

### arr.sort()，arr.reverse()

一个对数组进行排序，一个颠倒数组原来的顺序
sort() 方法用原地算法对数组的元素进行排序，并返回数组。
**默认排序顺序是在将元素转换为字符串，然后比较它们的 UTF-16 代码单元值**

```js
const arr = [1, 30, 4, 21, 100000]
arr.sort()
console.log(arr) // [1, 100000, 21, 30, 4]
```

sort()可以接收一个 compareFunction 作为参数：
如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前。
如果 compareFunction(a, b) 等于 0 ，a 和 b 的相对位置不变。
如果 compareFunction(a, b) 大于 0 ，b 会被排列到 a 之前。

```js
/* 定义两元素间的比较规则 */
function compare(a, b) {
  if (a < b) {
    // 按某种排序标准进行比较，a 小于 b，返回小于0的数，导致 a 排在 b 前面
    return -1
  }
  if (a > b) {
    return 1
  }
  // a must be equal to b
  return 0
}

/* 等同于如下的比较规则 */
function compare(a, b) {
  return a - b
}
```

### arr.indexOf(item)，arr.lastIndexOf(item)

一个查找给定元素的索引，一个查找给定元素最后一次出现的索引
如果存在则返回索引，不存在则返回`-1`

### arr.toString()，arr.join(str)

一个把数组转为字符串，用逗号分隔每一项，一个是把数组转为字符串，用 str 分隔每一项。str 不写则默认为逗号
arr.toString()等同于 arr.join()

### arr.slice()

slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的**浅拷贝**，前闭后开
所谓的浅拷贝，就是数组里的元素如果是引用类型，那么只会拷贝出来它的指针，而不是在堆区也拷贝一份这个元素

```js
let a = [{ x: 1, y: 2 }, 2, 3]
let b = a.slice(0)
b[0].x = 9
console.log(a) // [ { x: 9, y: 2 }, 2, 3 ]
```

### arr.concat(arr1, arr2)

生成一个新数组，拼接原有数组，**浅拷贝**
也就是说如果成员是引用类型，那么只拷贝指针，不同地方的操作会影响相同的值

### arr.indexOf(item, indexStart)

返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1

### arr.lastIndexOf(item, indexStart)

返回在数组中可以找到一个给定元素的最后一个索引，如果不存在，则返回-1

### arr.forEach()

forEach() 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除或者未初始化的项将被跳过（例如在稀疏数组上）。
forEach() 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach() 遍历到他们那一刻的值。

```js
arr.forEach(element => {
  /* ... */
})
arr.forEach((element, index) => {
  /* ... */
})
arr.forEach((element, index, array) => {
  /* ... */
})
```

### arr.filter(callback(element[, index[, array]])[, thisArg])

过滤方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。
回调函数要返回 true 或 false，以表示当前元素是否通过测试。
只有回调函数非箭头函数的形式，this 才能正常指向 thisArg 这个参数。

### arr.map(callback(currentValue[, index[, array]])[, thisArg])

映射出一个新的数组，回调函数返回对应生成的每个新数组的元素

### arr.every(callback(element[, index[, array]])[, thisArg])

every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

### arr.some(callback(element[, index[, array]])[, thisArg])

some() 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。

### arr.reduce()

归并方法对数组中的每个元素按序执行一个由您提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后返回最终的那个返回值。
第一次执行回调函数时，不存在“上一次的计算结果”。如果需要回调函数从数组索引为 0 的元素开始执行，则需要传递初始值。否则，数组索引为 0 的元素将被作为初始值 initialValue

```js
let arr = [1, 2, 3, 4]
// let initVal = 0
// let count = arr.reduce((prev, current) => prev + current, initVal)
let count = arr.reduce((prev, current) => prev + current)
console.log(count) // 10
console.log(initVal) // 0
```

## 2. Object（对象）

在 JS 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。对象是由属性和方法组成的。

1. 可以用`new Object()`创建，
2. 也可以用字面量创建，
3. 也可以也可以自己写一个构造函数，用`new 构造函`数创建

对象中的方法，直接用匿名函数，调用时用`属性名(参数)`

```js
let obj = new Object()
obj.name = 'zs'
obj.age = 14

let obj = {
  name: 'zs',
  age: 14,
}

function Person(name, age) {
  this.name = name
  this.age = age
}
let obj = new Person() // { name: undefined, age: undefined }
let obj = new Person('zs', 14) // { name: 'zs', age: 14 }
```

判断一个对象是否为空

```js
/* 1 */
JSON.stringify(obj) === {} // 但可能失效，如 {x:()=>{}}不是空对象，但调用stringify方法返回也是{}
/* 2 */
Object.keys(obj).length === 0 // Object.keys方法返回对象可枚举属性名称的数组 （字符串数组）
/* 3 */
Object.getOwnPropertyNames(obj).length === 0 // 包括不可枚举属性但不包括 Symbol 值作为名称的属性
```

获取高度嵌套对象中的属性
对象的解构赋值：

```js
let respond = {
  code: 200,
  data: {
    code: 200,
    data: {
      list: [1, 2, 3],
    },
  },
}

let { data: res } = respond
console.log(res) // { code: 200, data: { list: [ 1, 2, 3 ] } }

let {
  data: { data: res },
} = respond
console.log(res) // { list: [ 1, 2, 3 ] }

let {
  data: {
    code, // 这里是code: code的缩写，第二个code是声明的变量
    data: { list: res },
  },
} = respond
console.log(code) // 200
console.log(res) // [ 1, 2, 3 ]
```

添加或修改对象中的属性值：
直接覆盖就行，后面的会覆盖前面的

```ts
let obj = { a: 1, b: 2, a: 3 }
console.log(obj) // { a: 3, b: 2}
```

### for in 和 for of 的区别

for...in 是为遍历对象属性而构建的
for...in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for...of 只遍历当前对象不会遍历原型链
对于数组的遍历，for...in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for...of 只返回数组的下标对应的属性值

```js
var triangle = { a: 1, b: 2, c: 3 }

function ColoredTriangle() {
  this.color = 'red'
}

ColoredTriangle.prototype = triangle

var obj = new ColoredTriangle()

for (var prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`)
  }
}

// Output:
// "obj.color = red"
```

## 3. Function（函数）

函数实际上是一个函数对象，而函数名只是指向这个函数的变量

### arguments 对象

当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。它是函数的**内置对象**，只在函数内部起作用，存储了传递的所有实参。
arguments 是具有 length 长度的对象，是一个伪数组，按照索方式存储数据，但不具有数组的 pop、push 等方法
可以使用`Array.from()`方法或扩展运算符`[...arguments]`将参数转换为真实数组：

```js
function func(a, b) {
  console.log(arguments.length)
  console.log(arguments[0])
}
let args = Array.from(arguments)
let args = [...arguments]
```

注意：
**箭头函数没有自己的 this 和 arguments，如果打印也能打印出来，但会是上一层的 arguments**

**如果编写兼容 ES6 的代码，那么优先推荐使用剩余参数**

### 剩余参数

剩余参数语法允许我们将一个不定数量的参数表示为一个数组
如果函数的最后一个命名参数以...为前缀，则它将成为一个由剩余参数组成的真数组

```js
function foo(a, b, ...rest) {
  /*
   * 传入的参数先绑定a、b，多余的参数以数组形式交给变量rest
   * rest没接收到参数时，则为一个空数组[]
   */
}
```

arguments 对象不是一个真正的数组，
而剩余参数是真正的 Array 实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach 或 pop

### 立即执行函数

立即执行函数 `(函数体)()`，里面的函数可以是任意类型：箭头函数，也可以是普通函数、匿名函数

```js
;(() => console.log(9))()
```

### 箭头函数

箭头函数如果后面没有大括号 则后面就是返回值
如果有大括号，则必须有 return 语句，否则返回为 undefined
也就是说 如果要返回一个大括号包裹的对象，必须要用大括号在里面写 return 语句

```js
const getRes = () => {
  9
}
console.log(getRes()) // undefined

const getRes = () => 9
console.log(getRes()) // 9
```

与普通函数的区别

1. 箭头函数比普通函数更加简洁
2. 箭头函数没有自己的 this
   箭头函数不会创建自己的 this， 所以它没有自己的 this，它只会继承自己所在上下文的 this。所以箭头函数中 this 的指向在它在定义时已经确定了，之后不会改变。并且由于没有属于⾃⼰的 this，所以不会被 new 调⽤。
3. call()、apply()、bind()等方法不能改变箭头函数中 this 的指向
4. 箭头函数不能作为构造函数使用
5. 箭头函数没有自己的 arguments，但仍可使用剩余参数 rest
6. 箭头函数没有 prototype
7. 箭头函数不能用作 Generator 函数，不能使用 yield 关键字

## 4. Map（映射）

Map 对象保存键值对，并且能够记住键的原始插入顺序
有 set get has delete clear 等方法

```js
const map = new Map()
map.set('x', 0) // Map(1) { 'x' => 0 }
map.get('x') // 0
map.has('x') // true
map.delete('x') // Map(0) {}
map.clear() // // Map(0) {}
```

Map 构造函数可以接受一个二维数组来生成实例
Map 实例的 forEach() 方法按照插入顺序依次对 Map 中每个键/值对执行一次给定的函数

```js
const map = new Map([
  ['x', 0],
  ['y', 1],
])

map.forEach((value, key, map) => console.log(key, value))
```

## 5. Set（集合）

Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。
实例有 add delete clear has 方法

Set 构造函数可以接收一个一维数组来构造实例
Set 实例 forEach 方法：按照插入顺序，为 Set 对象中的每一个值调用一次 callBackFn。回调函数有三个参数，前两个参数都是 value 值，如果提供了第三个 thisArg 参数，回调中的 this 会是这个参数。

```js
const set = new Set([1, 2, 3, 'x'])
set.forEach((a, b) => console.log(a, b))
```

## 6. Math（数学）

Math 对象 是一个内置对象，它拥有一些数学相关的属性和方法
Math 的所有属性与方法都是静态的
Math 不是一个函数对象，也不是一个构造器

```js
Math.PI //3.141592653589793

Math.round(3.14) // 3 四舍五入
Math.ceil(3.14) // 4 向上取整
Math.floor(3.14) // 3 向下取整

Math.max(1, 2, 3) // 3 最大值
Math.min(1, 2, 3) // 1 最小值

Math.abs(-1) // 1 绝对值

Math.random() // 生成[0,1)上随机的浮点数

/* 生成[min,max]上的随机整数 */
function getRandomIntInclusive(min, max) {
  min = Math.ceil(min)
  max = Math.floor(max)
  //含最大值，含最小值
  return Math.floor(Math.random() * (max - min + 1)) + min
}
```

## 7. Date（日期）

### 创建日期对象

`new Date()`是一个构造函数，必须使用 new 来调用创建我们的日期对象。

```js
let date = new Date() // 2022-07-20T00:04:57.850Z
let date = new Date(1996, 9, 1) // 1996-09-30T16:00:00.000Z 月份从0开始，括号中的9表示10月
let date = new Date('2022-7-20 8:8:8') // 2022-07-20T00:08:08.000Z
```

### 创建时间戳（时间戳是数字类型的一个数字）

```js
let date = Date.now() // 1658275529271 时间戳

let date = +new Date() // 1658275529271 时间戳

let date = new Date() // 创建Data实例对象
date = date.valueOf() // 1658275529271 时间戳

let date = new Date()
date = date.getTime() // 1658275529271 时间戳
```

### 时间戳转日期

```js
let stamp = Date.now()
let date = new Date(stamp)
console.log(stamp) // 1658278861888
console.log(date) // 2022-07-20T01:01:01.888Z
```

### 格式化日期

格式化日期是针对 Date 对象，而不是时间戳这样的数字类型

```js
let date = new Date('2022-07-20 08:20:30') // 2022-07-20T00:20:30.655Z
date.getFullYear() // 2022
date.getMonth() // 6 // 月份从0开始计，6代表7月
date.getDate() // 20 日期
date.getDay() // 3 // 周几 1到6代表周一到周六，0代表周日
date.getHours() // 8
date.getMinutes() // 20
date.getSeconds() // 30
```

## 8. RegExp（正则表达式）

## JS 的包装类型（后台对基本类型的包装）

### 隐式包装

在 JavaScript 中，基本类型是没有属性和方法的，
但是：
为了便于操作基本类型的值，
在调用基本类型的属性或方法时，**JavaScript 会在后台隐式地将基本类型的值转换为对象**

例如获取基本类型字符串的长度：
在访问'abc'.length 时，JavaScript 将'abc'在后台转换成 String('abc')，然后再访问其 length 属性。

```js
let a = 'abc'
a.length // 3
a.toUpperCase // "ABC"
```

### 显式包装

可以用 Object()显式将基本类型转为包装类型，
反过来：
可以用包装类型的 valueOf()方法将包装类型转为基本类型

```js
let a = 'abc'
let b = Object(a) // String {a: 'abc'}
let c = b.valueOf() // 'abc'
```

## 数据类型转换

1. 转为字符串类型
   变量.toString()
   String(变量)
   变量+''

2. 转为数字类型
   Number(变量)

   ```js
   parseInt(变量) // 将 String 类型变量转为整数（不四舍五入，直接去掉小数部分）
   parseFloat(变量) // 将 String 类型变量转为浮点数（保留小数部分）
   ```

3. 转为布尔类型
   Boolean(变量)

   ```js
   Boolean('true') // true
   Boolean('false') // true
   Boolean('0') // true
   Boolean('abc') // true
   Boolean('') // false
   Boolean(null) // false
   Boolean(undefined) // false
   Boolean(NaN) // false
   ```

### 其他值转字符串

1. Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"
2. Boolean 类型，true 转换为 "true"，false 转换为 "false"
3. Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式
4. Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误
5. 对普通对象来说，除非自行定义 `toString()` 方法，否则会调用`Object.prototype.toString()`来返回内部属性 `[[Class]]` 的值，如`"[object Object]"`。如果对象有自己的 `toString()` 方法，字符串化时就会调用该方法并使用其返回值

::: tip
每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。
默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中 type 是对象的类型。
:::

### 其他值转数字

1. Undefined 类型，undefined 转换为 NaN
2. Null 类型，null 转换为 0
3. Boolean 类型的值，true 转换为 1，false 转换为 0
4. String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0
5. Symbol 类型的值不能转换为数字，会报错
6. 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字 `['1']==1 // true`

### 其他值转布尔

`'' +0 -0 NaN undefined null`转 false
其他转 true
