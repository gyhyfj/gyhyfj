# 三斜杠指令

三斜线指令是包含单个 XML 标签的单行注释，注释的内容会做为编译器指令使用。

使用要求：
三斜线指令仅可放在包含它的文件的最顶端，一个三斜线指令的前面只能出现单行或多行注释，这包括其它的三斜线指令。
如果它们出现在一个语句或声明之后，那么它们会被当做普通的单行注释，并且不具有特殊的涵义。

## types

`/// <reference types="node" />` 这个指令是用来声明依赖的,
对这些包的名字的解析与在 import 语句里对模块名的解析类似。 可以简单地把三斜线类型引用指令当做 import 声明的包。

通常仅当在你需要写一个 d.ts 文件时才使用这个指令，
若要在.ts 文件里声明一个对@types 包的依赖，使用--types 命令行选项或在 tsconfig.json 里指定。

这种写法会自动去添加`.d.ts`后缀去对应位置寻找类型声明文件
例如，想要引用 src 目录下的 env.d.ts，可以直接写`/// <reference types="./src/env" />`，也可以写成`/// <reference path="./src/env.d.ts" />`，但会被 eslint 报错，它推荐你使用 import 来进行引用
例如，把`/// <reference types="node" />`引入到声明文件，表明这个文件使用了`@types/node/index.d.ts`里面声明的名字，并且，这个包需要在编译阶段与声明文件一起被包含进来

注意：如果在配置文件中配置了 noResolve 编译选项，三斜线引用会被忽略。如果自身调用自身文件会报错

// TODO: 它们的区别是？？

## path

`/// <reference path="..." />` 指令是三斜线指令中最常见的一种。它用于声明文件间的依赖。
可以把它理解能 import，它可以告诉编译器在编译过程中要引入的额外的文件，也可以用于解决编译器报错

例如：

```ts
/* a.ts */
namespace A {
  export const fn = () => 'a'
}
```

```ts
/* b.ts */
namespace A {
  export const fn2 = () => 'b'
}
```

```ts
/* index.ts */
///<reference path="./index2.ts" />
///<reference path="./index3.ts" />

console.log(A)
```

## no-default-lib

`/// <reference no-default-lib="true" />` 这个指令是把一个文件标记成默认库，这个指令告诉编译器在编译过程中不要包含这个默认库。
你会在 lib.d.ts 文件和它不同的变体的顶端看到这个注释。

## amd-module

`/// <amd-module name='NamedModule'/>` 默认情况下生成的 AMD 模块都是匿名的。 但是，当一些工具需要处理生成的模块时会产生问题，amd-module 指令允许给编译器传入一个可选的模块名
