# Utils Type

## Record

```ts
/**
 * Construct a type with a set of properties K of type T
 */
type Record<K extends keyof any, T> = {
  [P in K]: T
}
```

即将 K 中的每个属性([P in K]),都转为 T 类型
示例 1：

```ts
type petsGroup = 'dog' | 'cat' | 'fish'
interface IPetInfo {
  name: string
  age: number
}

type IPets = Record<petsGroup, IPetInfo>

const animalsInfo: IPets = {
  dog: {
    name: 'dogName',
    age: 2,
  },
  cat: {
    name: 'catName',
    age: 3,
  },
  fish: {
    name: 'fishName',
    age: 5,
  },
}
```

示例 2（自己再添加个属性）：

```ts
type petsGroup = 'dog' | 'cat' | 'fish'
interface IPetInfo {
  name: string
  age: number
}

type IPets = Record<petsGroup | 'otherAnamial', IPetInfo>

const animalsInfo: IPets = {
  dog: {
    name: 'dogName',
    age: 2,
  },
  cat: {
    name: 'catName',
    age: 3,
  },
  fish: {
    name: 'fishName',
    age: 5,
  },
  otherAnamial: {
    name: 'otherAnamialName',
    age: 10,
  },
}
```

示例 3：
用了 reduce 的特性，遍历了一下数据，然后将所有的方法体放在一个对象中，最终结果用 httpMethods 接受，再将 httpMethods 对外暴露出去，那么外面就可直接调用了

```ts
enum IHttpMethods {
  GET = 'get',
  POST = 'post',
  DELETE = 'delete',
  PUT = 'put',
}

const methods = ['get', 'post', 'delete', 'put']

interface IHttpFn {
  <T = any>(url: string, config?: AxiosRequestConfig): Promise<T>
}

type IHttp = Record<IHttpMethods, IHttpFn>

const httpMethods: IHttp = methods.reduce((map: any, method: string) => {
  map[method] = (url: string, options: AxiosRequestConfig = {}) => {
    const { data, ...config } = options
    return (axios as any)
      [method](url, data, config)
      .then((res: AxiosResponse) => {
        if (res.data.errCode) {
          //todo somethins
        } else {
          //todo somethins
        }
      })
  }
  return map
}, {})

export default httpMethods
```

## Readonly

将所有属性变为只读
将所有只读属性（如果有）变为非只读

```ts
type Readonly<T> = {
  readonly [K in keyof T]: T[K]
}

type ToMutable<T> = {
  -readonly [K in keyof T]: T[K]
}
```

示例：（除了接口的成员外，对数组也同样生效）

```ts
type Obj = typeof obj
// type Obj = {
//   name: string;
//   age: number;
// }

type ReadonlyObj = Readonly<Obj>
// type ReadonlyObj = {
//   readonly name: string;
//   readonly age: number;
// }

type MutableObj = ToMutable<ReadonlyObj>
// type MutableObj = {
//   name: string;
//   age: number;
// }

type Test = {
  readonly name: string
  age: number
}

type MutableTest = ToMutable<Test>

type Arr = readonly [1]
type MutableArr = ToMutable<Arr>
// type MutableArr = [1]
```

## Partial

```ts
/**
 * Make all properties in T optional
  将T中的所有属性设置为可选
 */
type Partial<T> = {
  [P in keyof T]?: T[P]
}
// keyof 将一个接口对象的全部属性取出来变成联合类型
// in 我们可以理解成for-in，P是key，遍历keyof T联合类型的每一项
// ?这个操作就是将每一个属性变成可选项
// T[P] 索引访问操作符，与JS中访问属性值的操作类似
```

```ts
// 使用前：
type Person = {
  name: string
  age: number
}

type p = Partial<Person>

//  相当于：
type p = {
  name?: string | undefined
  age?: number | undefined
}
```

## Pick

```ts
/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick<T, K extends keyof T> = {
  [P in K]: T[P]
}
```

```ts
interface Person {
  name: string
  age: number
  id: number
  sex: 0 | 1
}

// 问女生年纪不太礼貌，所以我们不需要 age 这个属性
type Woman = Pick<Person, 'name' | 'id'>

// 此时 Woman 等效于 Female
interface Female {
  name: string
  id: number
}
```

## Omit

```ts
type Omit<T, K extends string | number | symbol> = {
  [P in Exclude<keyof T, K>]: T[P]
}
```

Omit 与 Pick 作用相似，只不过 Omit 是：以一个类型为基础支持剔除某些属性，然后返回一个新类型

```ts
interface User {
  id: number
  name: string
  age: number
  sex: 0 | 1
  tel: number
}

type EditUser = Omit<User, 'id' | 'name'> // 就是在 User 的基础上，去掉 id 和 name 属性
```

## Required

```ts
/**
 * Make all properties in T required
 */
type Required<T> = {
  [P in keyof T]-?: T[P]
}
```

将类型中所有选项变为必选，移除允许 undefined 这样的类型

```ts
type Person = {
  name?: string | undefined
  age?: number | undefined
}

type p = Required<Person>

// 相当于
type p = {
  name: string
  age: number
}
```
