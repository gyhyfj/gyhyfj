# namespace 命名空间

## 场景：

提供类似模块化开发的方式
在代码量较大的情况下，为了避免各种变量命名的冲突，尽可能少的声明全局变量参数，可将相似功能的函数、类、接口等封装到一起，对外提供统一的暴露接口
在外部可以使用`.`的形式访问其内部通过 export 暴露的成员

## 语法：

- 只有通过 export 暴露的成员才能在外部访问到
- 多个相同名称的命名空间会自动进行合并
- 同一名称下的不同空间可以有相同名称的非 export 成员
- 命名空间是可以嵌套使用

```ts
namespace Space {
  export let a = 0
}

namespace Space {
  a = 1
  export let b = 2
}

console.log(Space.a, Space.b) // 1 2
```

## 原理：

TypeScript 的命名空间就是以闭包的形式实现的

- 每一个命名空间的名称在 js 中就是一个全局变量（相同名称的空间用的是同一个变量，我将该变量称为名称变量，如上方的 var A; var B;，名称变量实际就是一个存储 export 内容的对象）
- 每一个命名空间在 js 中都是一个传入其对应名称变量的立即执行函数
- 命名空间内通过 export 暴露的内容在 js 中会挂载到其对应的名称变量中，这也就是同一名称不同空间的命名空间能够相互访问其内部 export 成员的原因（因为它们接受的是同一个名称变量）
- 命名空间内非 export 暴露的内容在 js 中不会挂载到其对应的名称变量中，而只是在其立即执行函数中声明，并只对当前函数空间生效

```ts
namespace A {
  // s没有export，它只在当前空间有效
  let s = 0
  export function getS1() {
    console.log(s)
  }
}
namespace A {
  // s没有export，它只在当前空间有效
  let s = 1
  export function getS2() {
    console.log(s)
  }
}

A.getS1() // 0
A.getS2() // 1
```

编译后

```js
'use strict'
var A // 命名空间 A
;(function (A) {
  // s没有export，它只在当前空间有效
  let s = 0
  function getS1() {
    console.log(s)
  }
  A.getS1 = getS1
})(A || (A = {}))
;(function (A) {
  // s没有export，它只在当前空间有效
  let s = 1
  function getS2() {
    console.log(s)
  }
  A.getS2 = getS2
})(A || (A = {}))

A.getS1() // 0
A.getS2() // 1
console.log(A) // { getS1: [Function: getS1], getS2: [Function: getS2] }
```

## 模块化

可以将其抽离到一个单独的 ts 文件内，变成模块化的空间

```ts
// src/a.ts
export namespace A {
  export let s = 99
}
```

```ts
// src/hello.ts
import { A } from './a'
console.log(A.s) // 99
```

## 空间别名

使用 `import q = x.y.z` 来为常用对象创建更短的名称

```ts
namespace A {
  export namespace B {
    export class C {
      constructor() {
        console.log(999)
      }
    }
  }
}

import MyC = A.B.C
new MyC() // 999  与new A.B.C()等价
new A.B.C() // 999
```
