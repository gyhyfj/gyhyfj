# namespace 命名空间

命名空间是位于全局命名空间下的一个普通的带有名字的 JavaScript 对象。
任何使用 module 关键字来声明一个内部模块的地方都应该使用 namespace 关键字来替换

## 场景：

提供类似模块化开发的方式
在代码量较大的情况下，为了避免各种变量命名的冲突，尽可能少的声明全局变量参数，可将相似功能的函数、类、接口等封装到一起，对外提供统一的暴露接口
在外部可以使用`.`的形式访问其内部通过 export 暴露的成员

## 语法：

- 只有通过 export 暴露的成员才能在外部访问到
- 多个相同名称的命名空间会自动进行合并
- 同一名称下的不同空间可以有相同名称的非 export 成员
- 命名空间是可以嵌套使用

```ts
namespace Space {
  export let a = 0
}

namespace Space {
  a = 1
  export let b = 2
}

console.log(Space.a, Space.b) // 1 2
```

## 原理：

TypeScript 的命名空间就是以闭包的形式实现的

- 每一个命名空间的名称在 js 中就是一个全局变量（相同名称的空间用的是同一个变量，我将该变量称为名称变量，如上方的 var A; var B;，名称变量实际就是一个存储 export 内容的对象）
- 每一个命名空间在 js 中都是一个传入其对应名称变量的立即执行函数
- 命名空间内通过 export 暴露的内容在 js 中会挂载到其对应的名称变量中，这也就是同一名称不同空间的命名空间能够相互访问其内部 export 成员的原因（因为它们接受的是同一个名称变量）
- 命名空间内非 export 暴露的内容在 js 中不会挂载到其对应的名称变量中，而只是在其立即执行函数中声明，并只对当前函数空间生效

```ts
namespace A {
  // s没有export，它只在当前空间有效
  let s = 0
  export function getS1() {
    console.log(s)
  }
}
namespace A {
  // s没有export，它只在当前空间有效
  let s = 1
  export function getS2() {
    console.log(s)
  }
}

A.getS1() // 0
A.getS2() // 1
```

编译后

```js
'use strict'
var A // 命名空间 A
;(function (A) {
  // s没有export，它只在当前空间有效
  let s = 0
  function getS1() {
    console.log(s)
  }
  A.getS1 = getS1
})(A || (A = {}))
;(function (A) {
  // s没有export，它只在当前空间有效
  let s = 1
  function getS2() {
    console.log(s)
  }
  A.getS2 = getS2
})(A || (A = {}))

A.getS1() // 0
A.getS2() // 1
console.log(A) // { getS1: [Function: getS1], getS2: [Function: getS2] }
```

## 模块化

可以将其抽离到一个单独的 ts 文件内，变成模块化的空间

```ts
// src/a.ts
export namespace A {
  export let s = 99
}
```

```ts
// src/hello.ts
import { A } from './a'
console.log(A.s) // 99
```

## 空间别名

使用 `import q = x.y.z` 来为常用对象创建更短的名称
对于值来讲， import 会生成与原始符号不同的引用，所以改变别名的 var 值并不会影响原始变量的值。

```ts
namespace A {
  export namespace B {
    export class C {
      constructor() {
        console.log(999)
      }
    }
  }
}

import MyC = A.B.C
new MyC() // 999  与new A.B.C()等价
new A.B.C() // 999
```

## 分离到多文件

当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护

将命名空间分割成多个文件。 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。 因为不同文件之间存在依赖关系，所以我们加入三斜杠指令引用标签来告诉编译器文件之间的关联

当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式
第一种方式，把所有的输入文件编译为一个输出文件，需要使用--outFile 标记 `tsc --outFile sample.js Test.ts` （这里的 Test.ts 用三斜杠指令引入了关联的 ts 文件）
第二种方式，我们可以编译每一个文件（默认方式），那么每个源文件都会对应生成一个 JavaScript 文件

## 外部命名空间

描述不是用 TypeScript 编写的类库的类型，我们需要声明类库导出的 API。由于大部分程序库只提供少数的顶级对象，命名空间是用来表示它们的一个好办法。形如：

```ts
/* D3.d.ts */
declare namespace D3 {
  export interface Selectors {
    select: {
      (selector: string): Selection
      (element: EventTarget): Selection
    }
  }

  export interface Event {
    x: number
    y: number
  }

  export interface Base extends Selectors {
    event: Event
  }
}

declare const d3: D3.Base
```

## 命名空间与模块的区别

像命名空间一样，模块可以包含代码和声明。 不同的是模块可以声明它的依赖。

引用模块文件一个常见的错误是使用`/// <reference>`引用模块文件，应该使用 import。
因为使用 import 后，编译器首先尝试去查找相应路径下的.ts，.tsx 再或者.d.ts。 如果这些文件都找不到，编译器会查找外部模块声明，不必要再用三斜杠指令去引用

还有就是有的情形如果使用命名空间会很混乱：

```ts
/* shapes.ts */
export namespace Shapes {
  export class Triangle {
    /* ... */
  }
  export class Square {
    /* ... */
  }
}
```

```ts
/* shapeConsumer.ts */
import * as shapes from './shapes'
let t = new shapes.Shapes.Triangle() // shapes.Shapes?
```

TypeScript 中完全没有必要把导出的符号包裹在一个命名空间里，因为不用担心不同模块在相同作用域内重名，因为人们会为它们重命名的，
所以完全没有必要把导出的符号包裹在一个命名空间里。

再次重申，不应该对模块使用命名空间，使用命名空间是为了提供逻辑分组和避免命名冲突。模块文件本身已经是一个逻辑分组，并且它的名字将会由导入这个模块的代码指定，所以没有必要为导出的对象增加额外的模块层

下面是改进的例子

```ts
/* shapes.ts */
export class Triangle {
  /* ... */
}
export class Square {
  /* ... */
}
```

```ts
/* shapeConsumer.ts */
import * as shapes from './shapes'
let t = new shapes.Triangle()
```
