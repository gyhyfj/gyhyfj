# 装饰器

若要启用实验性的装饰器特性，你必须在命令行或 tsconfig.json 里启用编译器选项 `"experimentalDecorators": true` `emitDecoratorMetadata": true`

装饰器是一种特殊类型的声明，它能够被附加到 类声明，方法， 访问符，属性，参数 上

## 类装饰器

先有一个类

```ts
class A {
  constructor() {}
}
```

然后定义一个类装饰器函数
他会把 ClassA 的构造函数传入你的 watcher 函数当做第一个参数
好处是不用去看代码，通过构造函数的原型链增加属性和方法

```ts
const watcher: ClassDecorator = (target: Function) => {
  target.prototype.getParams = <T>(params: T): T => {
    return params
  }
}
```

使用的时候 直接通过@函数名使用

```ts
@watcher
class A {
  constructor() {}
}

const a = new A()
console.log((a as any).getParams('123'))
```

可以用装饰器工厂让装饰器可以接受参数
其实也就是一个高阶函数，外层的函数接受值，里层的函数最终接受类的构造函数

```ts
const watcher = (name: string): ClassDecorator => {
  return (target: Function) => {
    target.prototype.getParams = <T>(params: T): T => {
      return params
    }
    target.prototype.getOptions = (): string => {
      return name
    }
  }
}

@watcher('name')
class A {
  constructor() {}
}

const a = new A()
console.log((a as any).getParams('123'))
```

可以组合使用多个装饰器
先定义多个装饰器函数，再依次用@调用

```ts
const watcher = (name: string): ClassDecorator => {
  return (target: Function) => {
    target.prototype.getParams = <T>(params: T): T => {
      return params
    }
    target.prototype.getOptions = (): string => {
      return name
    }
  }
}
const watcher2 = (name: string): ClassDecorator => {
  return (target: Function) => {
    target.prototype.getNames = (): string => {
      return name
    }
  }
}

@watcher2('name2')
@watcher('name')
class A {
  constructor() {}
}

const a = new A()
console.log((a as any).getOptions())
console.log((a as any).getNames())
```

## 方法装饰器

用在类的方法前，返回三个参数：

1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。
3. 成员的属性描述。

```ts
const met: MethodDecorator = (...args) => {
  console.log(args)
}

class A {
  constructor() {}
  @met
  getName(): string {
    return '小满'
  }
}

const a = new A()
// [
//   {},
//   'getName',
//   {
//     value: [Function: getName],
//     writable: true,
//     enumerable: false,
//     configurable: true
//   }
// ]
```

## 属性装饰器

返回两个参数

1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 属性的名字。

```ts
const met: PropertyDecorator = (...args) => {
  console.log(args)
}

class A {
  @met
  // @ts-ignore
  name: string
  constructor() {}
}

const a = new A()
// [ {}, 'name', undefined ]
```

## 参数装饰器

返回三个参数

1. 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。
2. 成员的名字。
3. 参数在函数参数列表中的索引。

```ts
const met: ParameterDecorator = (...args) => {
  console.log(args)
}

class A {
  constructor() {}
  setParasm(@met name: string = '213') {}
}

const a = new A()
// [ {}, 'setParasm', 0 ]
```
