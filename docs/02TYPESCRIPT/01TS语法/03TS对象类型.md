# 对象类型

对象类型: object ( 包括，数组、对象、函数等对象 )

:::warning
TS 中的 Object 与 object 与 {}
Object 是接口 Object，原型链顶级对象，所以 let a:Object 可以接收任意类型的值
object 是除去简单类型的对象类型，let a:object 可以接收对象 数组 或函数，一般常用于泛型约束 extend
{} 相当于 new Object()，与类型 Object 相似，可以接受任何值 `let m: {} = 99`
这三个类型约束的对象类型，都无法进行修改操作，尽量不要用于约束一个变量的类型

```ts
type NonNullable<T> = T & {} // 如果没有交集则是 never
type X = NonNullable<number> // type X = number
type Z = NonNullable<null> // never 好，得到了never
type Y = null & {} // never
```

:::

## 数组类型

可以用 `类型[]` 也可以用 `泛型` 定义

```ts
let numberArr: number[] = [1, 3, 5]

let numberArr: Array<number> = [1, 3, 5]
```

多维数组类型：

```ts
let data: number[][] = [
  [1, 2],
  [3, 4],
]
```

arguments 类数组
注意：箭头函数没有自己的 arguments，但仍可使用剩余参数 rest
TS 内置有对象 IArguments 定义

```ts
// arguments类数组
function Arr(...args: any): void {
  //ts内置对象IArguments 定义
  let arr: IArguments = arguments
}
//其中 IArguments 是 TypeScript 中定义好了的类型，它实际上就是：
interface IArguments {
  /** Iterator */
  [Symbol.iterator](): IterableIterator<any>
}
```

剩余参数数组：
是真正的数组，可以在形参列表中限制数组类型，也可以是 `any[]`
剩余参数不会含有前面的可选或必选参数

```ts
function add(...rest: number[]) {
  console.log(rest)
}
```

TS 中数组的方法也会对接受的参数类型进行约束

## 函数类型

在 JavaScript 中, 有两种常见的定义函数的方式, 函数声明和函数表达式

```js
function sum(x, y) {
  return x + y
}
let mySum = function (x, y) {
  return x + y
}
```

约束类型的完整方式如下

```ts
function add1(n1: number, n2: number): number {
  return n1 + n2
}

let add2: (n1: number, n2: number) => number = (
  n1: number,
  n2: number
): number => {
  return n1 + n2
}
```

函数如果没有返回值，返回类型就是 void
返回值被约束为 null 或 undefined 会报错

可选参数：
TS 会将添加了默认值的参数识别为可选参数，且**不受**「可选参数必须接在必需参数后面」的限制, 带默认值的参数允许出现在参数列表任意位置

```ts
function greet(name: string = 'zs'): void {
  console.log('Hello ' + name)
}
```

函数重载

重载是方法名字相同，而参数不同，返回类型可以相同也可以不同。

下面例子中我们重复定义了多次函数 reverse, 前几次都是函数定义, 最后一次是函数实现。

TS 会优先从最前面的函数定义开始匹配, 所以多个函数定义如果有包含关系, 需要优先把精确的定义写在前面。

```ts
function reverse(x: number): number
function reverse(x: string): string
function reverse(x: number | string): number | string | void {
  if (typeof x === 'number') {
    return Number(x.toString().split('').reverse().join(''))
  } else if (typeof x === 'string') {
    return x.split('').reverse().join('')
  }
}
```

## 对象类型

TS 中对象的类型就是在约束对象的结构：有什么类型的属性和方法

```ts
let person: { name: string; age: number; sayHi(name: string): void } = {
  name: 'zs',
  age: 26,
  sayHi(name) {
    console.log('Hi ' + name)
  },
}
```

对象的属性或方法必须与对象的类型注解吻合，不可多，且只有可选类型的成员可以缺少

## TS 与 JS 内置对象

TS 内置对象
当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了，
而他们的定义文件，则在[TypeScript 核心库的定义文件](https://github.com/Microsoft/TypeScript/tree/main/src/lib)中

ES 内置对象
Boolean、Number、String、RegExp、Date、Error

DOM 和 BOM 内置对象
Document、HTMLElement、Event、NodeList 等

Promise 对象
类型为 resolve 或 reject 出去的值的泛型

```ts
function promise(): Promise<number> {
  return new Promise<number>((resolve, reject) => {
    resolve(1)
  })
}

promise().then(res => {
  console.log(res)
})
```
