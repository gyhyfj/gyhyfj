# 新增类型

联合类型、交叉类型、元组、枚举、字面量类型、自定义类型（类型别名）、接口、void、any、unknown、never

## 联合类型

联合类型使用`|`连接

```ts
let arr: (number | string)[] = ['1', 'a']
```

当 TS 不确定一个联合类型的变量到底是哪个类型的时候, 我们只能访问联合的类型里共有的属性或方法

但当联合类型的变量在被赋值的时候, 会根据类型推论的规则推断出一个类型，推断出类型后, 可以且只可以访问它所有的属性和方法

## 交叉类型

交叉类型是将多个类型合并为一个类型，使用`&`连接，它包含了所需的所有类型的特性，相当于约束更加严苛

用于 interface，可以临时得到多个接口联合的类型约束，但不能用于生成新接口
想得到新接口需要用 extends 去定义

```ts
interface IA {
  x: number
}
interface IB {
  y: number
}

let val: IA & IB = {
  x: 1,
  y: 2,
}
```

用于对象类型的 type，可以用来定义新 type

```ts
type TA = { x: number }
type TB = TA & { y: number }
// 相当于
type TB = TA & {
  y: number
}
```

## 元组

元组类型是另一种类型的数组, 确切地知道包含多少个元素, 以及特定索引对应的类型，且不允许赋值时越界

为元组类型的变量赋值时候, 需要提供所有指定的项
但仅仅是在赋值运算的时候起约束作用

元组的好处在于可以把多个元素作为一个单元传递。如果一个方法需要返回多个值，可以把这多个值作为元组返回，而不需要创建额外的类来表示

```ts
let position: [number, number] = [3.14, 3.14]

position.push(3.14) // 允许
console.log(position) // [ 3.14, 3.14, 3.14 ]
```

## 枚举

枚举 enum 类型用于取值被限定在一定范围内的场景, 比如一周只能有七天, 颜色限定为红绿蓝等

枚举中的值以逗号分隔

枚举中的标识符不能重复，但值可以重复

功能类似于字面量类型 + 联合类型

注意: 一般约定枚举名称 / 枚举中的值以大写字母开头

```ts
/* 数字枚举 */
enum Direction {
  Up, // 0
  Down,
  Left,
  Right,
}

// 定义好后直接使用枚举名称作为类型注解
function changeDirection1(direction: Direction) {
  console.log(direction)
}

// 枚举成员会被赋值为从 0  开始递增的数字
// 直接通过点 (.) 语法访问枚举的成员
// changeDirection1(Direction.Up) // 打印结果是 0
// 同时也会对枚举值到枚举名进行反向映射
// console.log(Direction['Right']) // 打印结果是 3

// 也可以给枚举中的成员初始化值, 可以有缺省, 若没有全部赋值, 则后面的按前面已赋值的自增
enum Direction1 { // 数字枚举
  Up = 2,
  Down,
  Left = 5,
  Right,
}
function changeDirection2(direction: Direction1) {
  console.log(direction)
}
// changeDirection2(Direction1.Up) // 打印结果是 2
// changeDirection2(Direction1.Down) // 打印结果是 3
// changeDirection2(Direction1.Right) // 打印结果是 6

enum device {
  phone = 2,
  notebook = 1,
  desktop,
}

console.log(device.phone) // 2
console.log(device[2]) // desktop
console.log(device.phone == device.desktop) // true
// 重要：这里的desktop会自增成2，与上面的phone的值相等

/* 字符串枚举 */
// 也可以给枚举赋值字符串, 称为字符串枚举
// 字符串枚举的每个成员必须有初始值
enum Direction2 { // 字符串枚举
  Up = 'Up',
  Down = 'Down',
  Left = 'Left',
  Right = 'Right',
}

/* 接口枚举 */
enum Types {
  a,
  b,
}
interface A {
  red: Types.a
}
let obj: A = {
  red: Types.a,
}

/* const枚举 */
// 声明枚举只能使用const，不能用let或var
// 普通声明的枚举编译完后是个对象，const 声明的枚举会被编译成常量
const enum Enum {
  fall,
}

/* 反向映射 */
// 注意的是 不会为字符串枚举成员生成反向映射
enum Enum {
  fall,
}
let a = Enum.fall
console.log(a) // 0
let nameOfA = Enum[a]
console.log(nameOfA) // fall
console.log(typeof nameOfA) // string

// 注意: 枚举不仅用作类型, 而且枚举成员还有值,
// 所以其他的类型会在编译为 JS 代码时自动移除, 但枚举类型会被编译为 JS 代码
// 可以当做一个命名空间来用了
enum Names {
  TEST = 'TEST',
  BASE = 'NAME',
}
console.log(Names.BASE) // NAME

// 一般情况下, 推荐使用字面量类型 + 联合类型组合的方式, 这样比枚举更直观

// 枚举的键转为联合类型与枚举的值转为联合类型
enum Direction {
  Up = 2,
  Down,
  Left = 5,
  Right,
}

type Key = keyof typeof Direction // type Key = "Up" | "Down" | "Left" | "Right"
type Value = `${Direction}` // type Value = "2" | "3" | "5" | "6"
```

## 字面量类型

某个特定的字符串也可以作为 TS 中的类型
不仅仅是字符串, 任意的 JS 字面量 (比如, 对象、数字等) 都可以作为类型使用

```ts
let str = 'Hello TS'
const str1 = 'Hello TS' // const str1: "Hello TS"
// str 是一个变量, 类型是 string
// str1 是常量, 类型是 'Hello TS', 一个字面量类型
```

相比于 string 类型, 使用字面量类型更加精确和严谨
比如如下函数**只能接收**传入`上下左右`四个类型的一个 (用了联合类型), 如: 传入 `const a= 'up'`

```ts
function changeDirection(direction: 'up' | 'down' | 'left' | 'right'): void {
  console.log(direction)
}
```

## any 类型和 unknown 顶级类型

可以对 any 进行任何操作，不需要检查类型，不阻止隐式类型转换

所有类型都可以分配给 unknown，但 unknown 比 any 更加安全和严格：

```ts
// 1. unkonwn 不能赋值给 any/unknown 外的其他类型
let a: unknown = 1
a = [1] // 不报错
let b: number = a // 报错，unknown 不能赋值给无辜的人

// 2. 如果是 any 类型的对象，获取它即使没有的属性不会报错，如果是 unknown，获取存在的属性也不行
let obj: unknown = { a: 1, b: 2 }
obj.a // 报错，对象的类型是 unknown，不能做取成员操作

// 可以把一个值先断言为 unknown，再断言为需要的类型，再做取成员操作，替代直接断言为 any
const { code } = (await uni.login({})) as unknown as {
  errMsg: string
  code: string
}
```

## never 类型

never 类型来表示不应该存在的状态
返回 never 的函数必须存在无法达到的终点
比如死循环，比如 throw new Error('msg')

与 void 的区别：void 类型只是没有返回值 但本身不会出错

应用场景：
比如 switch case 的兜底逻辑，如果正常根本不可能进入 default 语句，那么在 default 后面放一句 `const exhaustiveCheck: never = val;`，如果有进入到这个地方的可能那就是程序异常
原理：由于任何类型都不能赋值给 never 类型的变量，所以当存在进入 default 分支的可能性时，TS 的类型检查会及时帮我们发现这个问题

## 自定义类型（类型别名）

```ts
// 使用 type 关键字来创建类型别名
// 类型别名常用于联合类型
type CustomArr = (number | string)[]
// 创建类型别名后, 直接使用该类型别名作为变量的类型注解
let arr1: CustomArr = ['1', 'a']
```

## 接口

在面向对象语言中, 接口(Interfaces)是一个很重要的概念, 它是对行为的抽象, 而具体如何行动需要由类去实现

在 TypeScript 里, 接口的作用是为这些类型命名和为你的代码或第三方代码定义约束，只支持给对象指定类型

支持可选属性、只读属性、任意属性、继承

声明一个接口后，可以直接用接口名作为对象变量的类型
同样的，赋值时候属性必须完全对应，可选属性除外

```ts
interface IPerson {
  name: string
  age: number
  sayHi?(name: string): void
  // sayHi?: (name: string) => void
}

let person: IPerson = {
  name: 'zs',
  age: 26,
}``
```

可选属性、只读属性、任意属性
只读属性只能在创建时候被赋值
注意任意属性可以赋予不止一个属性

```ts
interface IPerson {
  readonly id: number
  name: string
  age?: number
  [propName: string]: any // 这里不需要一定写做propName, 类似于形参, 可以随便写, 但后面似乎必须是any
}

let tom: IPerson = {
  id: 1,
  name: 'Tom',
  is: 'cat', // 任意属性
  gender: 'male', // 可以赋予不止一个任意属性
}
```

接口的继承：
使用 extends 关键字继承另一个接口的全部成员 且增加新成员

```ts
interface Point2D {
  x: number
  y: number
}
interface Point3D extends Point2D {
  z: number
}
```

## 泛型

泛型是指在定义函数\接口\类的时候, 不预先指定具体类型, 而在使用时候再指定具体类型的一种特性

语法是函数名字后面跟一个<参数值>，参数名可以随便写，函数中用到类型的地方就用泛型替代，比如`:T[]`

当我们使用这个函数时候把参数的类型传递进去就 ok（也就是动态类型）

习惯用的泛型变量有 T(Type-类型) K(Key-对象中键的类型) V(Value-对象中值的类型) E(Element-元素的类型) U(Unknown-未知的类型)

可以使用不同的泛型参数名，只要使用时候在数量和使用方式上能对应就 ok

```ts
function Sub<T, U>(a: T, b: U): Array<T | U> {
  const params: Array<T | U> = [a, b]
  return params
}
Sub<Boolean, number>(false, 1)
```

比较下面两段代码：

```ts
function createArr(len: number, val: any): Array<any> {
  let result = []
  for (let i = 0; i < len; i++) {
    result[i] = val
  }
  return result
}

function createArray<T>(len: number, val: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < len; i++) {
    result[i] = val
  }
  return result
}

// T用来指代任意类型
// 用<>括起来放在参数列表括号前面
// 调用时候可以指定它的具体类型, 也可以不手动指定, 而让类型推论自动推算出来，这时候省略尖括号，不可以放个空的尖括号
createArray<string>(3, 'x') // ['x','x','x']
createArray(3, 'x') // ['x','x','x']
```

定义泛型时候, 可以一次定义多个类型参数

```ts
function swap<T, U>(tuple: [T, U]): [U, T] {
  return [tuple[1], tuple[0]]
}
```

泛型约束
extends 约束泛型必须符合某个类型，以在函数中使用这个类型有的属性或方法

```ts
// 在函数内部使用泛型变量的时候,由于事先不知道它是哪种类型,所以不能随意的操作它的属性或方法

// function loggingIdentity<T>(arg: T): T {
//   console.log(arg.length);
//   return arg;
// }
// index.ts(2,19): error TS2339: Property 'length' does not exist on type 'T'
// 上例中, 泛型 T 不一定包含属性 length, 所以编译的时候报错了
// 这时, 我们可以对泛型进行约束, 只允许这个函数传入那些包含 length 属性的变量, 这就是泛型约束
interface Lengthwise {
  length: number
}
function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length)
  return arg
}
// 上例中, 我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状, 也就是必须包含 length 属性
// 此时如果调用 loggingIdentity 的时候, 传入的 arg 不包含 length, 那么在编译阶段就会报错
```

keyof
通过 keyof 操作符可以获取某一个对象类型中的所有键类型组成的联合类型
keyof 是对类型的运算，得到的也是新类型

```ts
interface Cass {
  age: number
  myName: string
}

const person: Cass = {
  age: 6,
  myName: 'xiaoguaishou',
}

function prop<T extends object, K extends keyof T>(obj: T, key: K) {
  return obj[key]
}

// 下面这种写法和上面的写法在实际使用中的区别
// function prop(obj:Xiaoguaishou, key:string){
//     return obj[key];
// }
// 1.输出的结果都是一致
// 2.上面的方式在编码过程就能知道输入的类型是否正确，下面这种方式需要在运行之后

const age = prop(person, 'age')
const myName = prop(person, 'myName')
console.log('age====', age)
console.log('myName===', myName)
```

泛型接口
所以也可以用含有泛型的接口来定义函数的形状

```ts
interface SearchFunc {
  // 接口重复写了不报错??
  (source: string, subString: string): boolean
}
interface CreateArrayFunc {
  <T>(length: number, value: T): Array<T>
}
let createArray1: CreateArrayFunc
createArray1 = function <T>(length: number, value: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}
createArray(3, 'x') // ['x', 'x', ']

// 进一步, 可以把泛型参数提前到接口名上
interface CreateArrayFunc2<T> {
  (length: number, value: T): Array<T>
}
let createArray2: CreateArrayFunc2<any>
createArray2 = function <T>(length: number, value: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}
createArray(3, 'x') // ['x', 'x', 'x']
```

泛型类
与泛型接口类似, 泛型也可以用于类的类型定义中

```ts
class createSth<T> {
  value: T
  func: (x: T, y: T) => T
}
let myCreateSth = new createSth<number>()

// 泛型参数的默认类型
// 我们可以为泛型中的类型参数指定默认类型
// 当使用泛型时没有在代码中直接指定类型参数, 从实际值参数中也无法推测出时, 这个默认类型就会起作用
function createArray3<T = string>(length: number, value: T): Array<T> {
  let result: T[] = []
  for (let i = 0; i < length; i++) {
    result[i] = value
  }
  return result
}
```

如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型

```ts
// 如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型

// 函数: 之前学习过，我们可以使用重载定义多个函数类型
function reverse1(x: number): number
function reverse1(x: string): string
function reverse1(x: number | string): number | string | undefined {
  if (typeof x === 'number') {
    return Number(x.toString().split('').reverse().join(''))
  } else if (typeof x === 'string') {
    return x.split('').reverse().join('')
  }
}

// 接口: 接口中的属性在合并时会简单的合并到一个接口
// 注意，合并的属性的类型必须是唯一的, 如果重复了但类型不同则会报错
// 接口中方法的合并，与函数的合并一样

// 类: 类的合并与接口的合并规则一致
```

## 补充：类型推论

一些地方的类型注解可以省略不写
(1) 声明且初始化变量时候, 后面的代码会严格按赋值时推论的类型看待这个声明的的变量
(2) 决定函数返回值的时候, 例如返回两个 number 的相加, 那么返回值必定是 number, 可以省略而被推论
(3) **如果定义的时候没有赋值, 不管之后有没有赋值, 都会被推断成 any 类型而完全不被类型检查**

## 补充：类型断言

```ts
// 通过类型断言避免警告（读取的属性可能不存在）
const fn = (type: A | B): string => {
  return (type as A).run
}
// 可以使用类型断言来推断他传入的是A接口的值

// as const 对字面值的断言
let names2 = '小满' as const
names2 = 'aa' //无法修改

let a1 = [10, 20] as const
a1.unshift(30) // 错误，此时已经断言字面量为[10, 20],数据无法做任何修改

// 用来手动指定一个值的类型
// 语法:  值 as 类型,  或:  <类型>值 (第二种不推荐, 在jsx语法的ts版中不适用), as 类型是一种修饰符, 类似 : 类型
// 用例1: 使用类型断言, 将一个联合类型断言为其中一个类型, 以访问其独有的属性或方法
// 注意: 类型断言只能欺骗编译器, 无法避免运行时的错误, 所以尽量避免断言后调用方法或引用深层属性
// 用例2: 将一个父类断言为更加具体的子类, 以调用其属性和方法
// 注意: 如果只是互相继承的类而不是接口, 可以用instanceof实现同样的功能
// 用例3: 将任何一个类型断言为any
// (window as any).foo = 1 // 临时将window断言为any, 添加一个属性foo
// 注意: 将一个变量断言为any是解决TypeScript中类型问题的最后一个手段, 我们需要在类型的严格性和开发的便利性之间掌握平衡
// 用例4: 将any断言为一个具体的类型
// 遇到any类型的变量时, 我们可以选择无视它, 任由它滋生更多的any
// 我们也可以选择改进它, 通过类型断言及时的把 any 断言为精确的类型, 亡羊补牢, 使我们的代码向着高可维护性的目标发展
// 例如调用某个吃any吐any的函数, 可以调用完后立即将它断言为一个类型
// const tom=fooFunc('tom') as Cat
// 注意: 并不是任何一个类型都可以被断言为任何另一个类型, 只有他们能一方兼容另一方才可以

// 双重断言
// as any as Cat 可以先断言any再断言为其他任何类型, 打破断言限制, 非迫不得已勿用

// 类型断言 vs 类型转换
// 类型断言只会影响TypeScript编译时的类型, 类型断言语句在编译结果中会被删除
// 所以类型断言不是类型转换, 它不会真的影响到变量的类型

// 类型断言 vs 类型声明
// const tom=fooFunc('tom') as Cat
// const tom: Cat=fooFunc('tom') 可以同样解决这个问题, 接下来的代码中tom都变成了Cat类型
// 但两者有区别:
// a断言为b时, a和b有重叠的部分即
// a声明为b时, a必须具备b的所有属性和方法
// 所以类型声明是比类型断言更加严格的
// 所以为了增加代码的质量, 我们最好优先使用类型声明, 这也比类型断言的 as  语法更加优雅

// 类型断言 vs 泛型
// function getCacheData(key: string): any {
//   return (window as any).cache[key];
// }
// interface Cat {
//   name: string;
//   run(): void;
// }
// const tom = getCacheData('tom') as Cat;
// tom.run()
// 我们还有第三种方式可以解决这个问题, 那就是泛型
// function getCacheData<T>(key: string): T {
//   return (window as any).cache[key];
// }
// interface Cat {
//   name: string;
//   run(): void;
// }
// const tom = getCacheData<Cat>('tom');
// tom.run()
// 通过给getCacheData函数添加了一个泛型<T>, 我们可以更加规范的实现对getCacheData返回值
// 的约束, 这也同时去除掉了代码中的any, 是最优的一个解决方案.
```

## 补充：TS 中的类

```ts
// JavaScript中类的简单介绍:
// 类(Class): 定义了一件事物的抽象特点, 包含它的属性和方法
// 对象(Object): 类的实例, 通过 new  生成
// 面向对象(OOP)的三大特性: 封装、继承、多态
// 封装(Encapsulation): 将对数据的操作细节隐藏起来, 只暴露对外的接口. 外界调用端不需要
// (也不可能)知道细节, 就能通过对外提供的接口来访问该对象, 同时也保证了外界无法任意更改
// 对象内部的数据
// 继承(Inheritance): 子类继承父类, 子类除了拥有父类的所有特性外, 还有一些更具体的特性
// 多态(Polymorphism): 由继承而产生了相关的不同的类, 对同一个方法可以有不同的响应. 比
// 如 Cat 和 Dog 都继承自 Animal, 但是分别实现了自己的 eat 方法. 此时针对某一个实例, 我
// 们无需了解它是 Cat 还是 Dog, 就可以直接调用 eat 方法, 程序会自动判断出来应该如何执行
// eat
// 存取器(getter & setter): 用以改变属性的读取和赋值行为
// 修饰符(Modifiers): 修饰符是一些关键字, 用于限定成员或类型的性质. 比如 public 表示公
// 有属性或方法
// 抽象类(Abstract Class): 抽象类是供其他类继承的基类, 抽象类不允许被实例化. 抽象类中的
// 抽象方法必须在子类中被实现
// 接口(Interfaces): 不同类之间公有的属性或方法, 可以抽象成一个接口. 接口可以被类实现
// (implements). 一个类只能继承自另一个类, 但是可以实现多个接口
// 使用 class 定义类, 使用 constructor 定义构造函数.
// 通过 new 生成新实例的时候, 会自动调用构造函数.

// 类与接口 implements

interface Alarm {
  alert(): void
}

interface Light {
  on(): void
  off(): void
}

class Car implements Alarm, Light {
  alert(): void {
    console.log('car alert')
  }
  on(): void {
    console.log('light on')
  }
  off(): void {
    console.log('light off')
  }
}
// 上例中Car实现了Alarm和Light接口, 技能报警, 也能开关车灯

// 接口继承类(常见语言中是不可以的, 但TypeScript可以)
// 不推荐这样
class Point {
  x: number
  y: number
  // TypeScript不允许直接在constructor定义变量，需要在constructor上面先声明
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
}
interface Point3d extends Point {
  z: number
} // 也成功创建了一个类, 但不推荐
let point3d: Point3d = { x: 1, y: 2, z: 3 }

/* 类的修饰符 public private protected */
// public 修饰符 可以让你定义的变量 内部访问 也可以外部访问 如果不写默认就是public
// protected 修饰符 代表定义的变量私有的只能在内部和继承的子类中访问 不能在外部访问
// private 修饰符 代表定义的变量私有的只能在内部访问 不能在外部访问

/* static静态属性和方法 */
// 用static定义的属性，不可以通过this去访问，只能通过类名去调用
// static静态函数，同样也是不能通过this去调用，也是通过类名去调用

/* interface定义类 extends一个类，implements多个接口 */
interface PersonClass {
  get(type: boolean): boolean
}

interface PersonClass2 {
  set(): void
  school: string
}

class A {
  name: string
  constructor() {
    this.name = 'zs'
  }
}

class Person extends A implements PersonClass, PersonClass2 {
  school: string
  constructor() {
    super() // 在constructor中必须调用super方法,因为子类没有自己的this对象,而是继承父类的this对象,然后对其进行加工,而super就代表了父类的构造函数
    this.school = 'TSU'
  }
  get(type: boolean): boolean {
    return type
  }
  set() {}
}

/* 抽象类 abstract */
// 如果你写的类实例化之后毫无用处，此时你可以把他定义为抽象类
abstract class A {
  name: string
  constructor(name: string) {
    this.name = name
  }
  print(): string {
    return this.name
  }
  abstract getName(): string
}

class B extends A {
  constructor() {
    super('小满') // 在constructor中必须调用super方法,因为子类没有自己的this对象,而是继承父类的this对象,然后对其进行加工,而super就代表了父类的构造函数
  }
  getName(): string {
    return this.name
  }
}

let b = new B()
console.log(b.getName())
```

## 补充：interface 和 type 的区别

1.类型别名可以用于其它类型 （联合类型、元组类型、基本类型（原始值）），interface 不支持

```ts
type PartialPointX = { x: number }
type PartialPointY = { y: number }

// union(联合)
type PartialPoint = PartialPointX | PartialPointY

// tuple(元祖)
type Data = [PartialPointX, PartialPointY]

//primitive(原始值)
type Name = Number

// typeof的返回值
let div = document.createElement('div')
type B = typeof div
```

2.interface 可以多次定义，并被视为合并所有声明成员。type 不支持

```ts
interface Point {
  x: number
}
interface Point {
  y: number
}

const point: Point = { x: 1, y: 2 }
```

3.type 能使用 in 关键字生成映射类型，但 interface 不行

```ts
type Keys = 'firstname' | 'surname'

type DudeType = {
  [key in Keys]: string
}

const test: DudeType = {
  firstname: 'Pawel',
  surname: 'Grzybek',
}
```

4.默认导出方式不同

```ts
// inerface 支持在导出同时声明，默认导出 而type必须先声明后导出
export default interface Config {
  name: string
}
// Tips: 同一个js模块只能存在一个默认导出
type Config2 = { name: string }
export default Config2
```
