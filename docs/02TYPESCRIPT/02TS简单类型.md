# TS 简单类型

number/string/boolean/null/undefined/symbol(ES6)/bigint(ES10)

## 包装类型

TS 不允许将包装器对象的类型分配给基元类型

```ts
let a: string = new String('123') // err: 不能将类型“String”分配给类型“string”

let createdBoolean: boolean = new Boolean(1) // 报错！返回的是一个Boolean对象
let createdBoolean: Boolean = new Boolean(1) // 正确
let createdBoolean: boolean = Boolean(1) // 正确，不是构造函数，返回值是boolean类型
```

可以通过隐式包装或显式包装获取包装类型：

隐式包装：
在 JavaScript 中，基本类型是没有属性和方法的，但是：
为了便于操作基本类型的值，
在调用基本类型的属性或方法时，JavaScript 会在后台隐式地将基本类型的值**转换为对象**

例如获取基本类型字符串的长度：
在访问'abc'.length 时，JavaScript 将'abc'在后台转换成 String('abc')，然后再访问其 length 属性。

```js
let a = 'abc'
a.length // 3
a.toUpperCase // "ABC"
```

显示包装：
可以用 `Object()` 显式将基本类型转为包装类型，
反过来：可以用包装类型的 `valueOf()` 方法将包装类型转为基本类型

```js
let a = 'abc'
let b = Object(a) // String {a: 'abc'}
let c = b.valueOf() // 'abc'
```

## 空值类型

void undefined null
void 只是 ts 的类型
undefined 和 null 既是类型，又是值

如果在 `tsconfig.json` 的 `compilerOptions` 里开启严格模式，则 null 和 undefined 不能赋给 void 类型

否则 null 和 undefined 都可以赋值给 void

## symbol 类型

```ts
// symbol类型的值是通过Symbol构造函数创建的
let sym1: symbol = Symbol()
let sym2: symbol = Symbol('key') // 可选的字符串key

// Symbol的值是唯一的
const s1: symbol = Symbol()
const s2: symbol = Symbol()
s1 === s2 // false

// 用作对象属性的键
let sym: symbol = Symbol()
let obj = {
  [sym]: 'value',
}
console.log(obj[sym]) // value
```

## bigint 类型

可以通过 BigInt 构造器构造，

```ts
const huge: bigint = BigInt(9007199254740991)
const huge2: bigint = BigInt('9007199254740991') // 也可以传入字符串构造
```

也可以在一个整数字面量后面加 n 的方式定义一个 BigInt
但要求在 es2020 以上
需要在 `tsconfig.json` 的 `compilerOptions` 里配置 `"target": "ES2020"` 或 `"target": "ESNext"`

```ts
const huge: bigint = 9007199254740991n
typeof 1n === 'bigint' // true
```

JS 中支持除了 `>>>` 以外的运算
当使用 bigint 时，带小数的运算会被取整

TS 中禁止 number 类型和 bigint 类型的转换和运算

```ts
let huge: bigint = 1.9n // err: 不能将类型“number”分配给类型“bigint”。 bigint 文本必须是整数。

huge + 1 // err: 运算符“+”不能应用于类型“bigint”和“1”。

huge++ // 正确，因为支持 ++ 运算符
```
