# Vite 构建 Vue3 组件库

> 使用 pnpm 搭建出一个 Monorepo 环境
> 使用 vite 搭建一个基本的 Vue3 脚手架项目
> 开发调试一个自己的 UI 组件库
> 使用 vite 打包并发布自己的 UI 组件库

## 使用 pnpm 搭建 Monorepo 环境

Monorepo 简单来说就是单仓库 多项目
就是指在一个大的项目仓库中，管理多个模块/包（package）
目前很多我们熟悉的项目都是采用这种模式，比如 vant，比如 elementui，比如 vue3，以及我很喜欢的一个开源文档生成工具 vitepress
使用 pnpm 搭建 Monorepo 环境，是因为它简单高效，没有太多杂乱的配置

1. npm i pnpm -g
2. 在项目目录下初始化 package.json 文件 pnpm init
3. 创建配置文件.npmrc 写入 shamefully-hoist = true
   这一步是将你安装的依赖包的依赖包的依赖包的...都放到同一级别（扁平化），
   因为某些工具仅在根目录的 node_modules 下才有效，
   没有这步配置可能出问题
4. 实现 monorepo
   为了我们各个项目之间能够互相引用我们要新建一个 pnpm-workspace.yaml 文件将我们的包关联起来

   ```yaml
   packages:
     - 'packages/**'
     - 'examples'
   ```

   这样就能将我们项目下的 packages 目录和 examples 目录关联起来了，
   packages 文件夹存放我们开发的包，examples 用来调试我们的组件
   examples 文件夹就是接下来我们要使用 vite 搭建一个基本的 Vue3 脚手架项目的地方

## 安装对应依赖

我们开发环境中的依赖一般全部安装在整个项目根目录下，方便下面我们每个包都可以引用，所以在安装的时候需要加个 -w
`pnpm i vue@next typescript less -D -w`

然后配置 tsconfig.json 文件 `npx tsc --init`

## 在 examples 文件夹下搭建一个基于 vite 的 vue3 项目作为调试项目

1. 进入 examples 文件夹，执行`pnpm init`，创建 package.json 文件
2. 安装 vite 和@vitejs/plugin-vue
   @vitejs/plugin-vue 用来支持.vue 文件的转译
   `pnpm install vite @vitejs/plugin-vue -D -w`
3. 创建并配置 vite.config.ts 文件
   ```ts
   import { defineConfig } from 'vite'
   import vue from '@vitejs/plugin-vue'
   export default defineConfig({
     plugins: [vue()],
   })
   ```
4. 新建 index.html 文件，@vitejs/plugin-vue 会默认加载 examples 下的 index.html
5. 新建空白 app.vue 模板
6. 新建 main.ts
   ```ts
   import { createApp } from 'vue'
   import App from './app.vue'
   const app = createApp(App)
   app.mount('#app')
   ```
7. 解决报错`找不到模块"./app.vue"或其相应的类型声明`
   因为直接引入.vue 文件 TS 会找不到对应的类型声明；所以需要新建 typings 文件夹来专门放这些声明文件`typings/vue-shim.d.ts`
   ```ts
   declare module '*.vue' {
     import type { DefineComponent } from 'vue'
     const component: DefineComponent<{}, {}, any>
   }
   ```
8. 在 package.json 文件中配置 scripts 脚本启动命令` "dev": "vite"`

## utils 包

packages/utils
一般 packages 要有 utils 包来存放我们公共方法，工具函数等
新建 utils 目录后需要初始化它，让它变成一个包 `pnpm init`，
name 属性改为`@gyhyfj/utils`，表示这个 utils 包是属于 gyhyfj 这个组织下的
main 属性改为`index.ts`，这是是入口文件，在里面导出需要导出的内容

## 组件库包

components 是我们用来存放各种 UI 组件的包
新建 components 文件夹并执行 pnpm init 生成 package.json
新建 index.ts 入口文件并引入 utils 包

在 components 文件夹下新建 src，同时在 src 下新建各个要开发的组件目录，比如 button 组件目录和 icon 组件目录
在组件目录下新建 vue 文件，然后在形如 button/index.ts 中引入 vue 文件并把组件导出

```ts
import Button from './button.vue'
export default Button
```

因为我们开发组件库的时候不可能只有 button，所以我们需要一个 components/index.ts 将我们开发的组件全部集中导出

```ts
import Button from './button'

export { Button }
```

## 包之间的本地调试

进入 components 文件夹执行`pnpm install @gyhyfj/utils`
pnpm 会自动创建个软链接直接指向我们的 utils 包

## 在 example 目录下的 vue 项目中调试写好的组件

因为：
在 workspace 执行 pnpm i xxx 的时候 pnpm 会自动创建个软链接直接指向我们的 xxx 包

所以：
所以这里我们直接在 examples 执行：pnpm i xxx

然后：
就可以直接在测试项目下引入我们本地的 components 组件库了

## vite 打包

vite 有一个库模式专门为我们来打包这种库组件

在 components 下直接新建 vite.config.ts

```ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
export default defineConfig({
  build: {
    target: 'modules',
    //打包文件目录
    outDir: 'es',
    //压缩
    minify: false,
    //css分离
    //cssCodeSplit: true,
    rollupOptions: {
      //忽略打包vue文件
      external: ['vue'],
      input: ['src/index.ts'],
      output: [
        {
          format: 'es',
          //不用打包成.es.js,这里我们想把它打包成.js
          entryFileNames: '[name].js',
          //让打包目录和我们目录对应
          preserveModules: true,
          //配置打包根目录
          dir: 'es',
          preserveModulesRoot: 'src',
        },
        {
          format: 'cjs',
          entryFileNames: '[name].js',
          //让打包目录和我们目录对应
          preserveModules: true,
          //配置打包根目录
          dir: 'lib',
          preserveModulesRoot: 'src',
        },
      ],
    },
    lib: {
      entry: './index.ts',
      formats: ['es', 'cjs'],
    },
  },
  plugins: [vue()],
})
```

说明：
选择打包 cjs(CommonJS)和 esm(ESModule)两种形式，
cjs 模式主要用于服务端引用(ssr)，
而 esm 就是我们现在经常使用的方式，它本身自带 treeShaking 而不需要额外配置按需引入(前提是你将模块分别导出)，非常好用

到这里就已经可以直接打包了，components 下执行`pnpm run build`，就会打包出 es 和 lib 两个目录

但是：
这时打包的组件库只能给 js 项目使用，在 ts 项目下运行会出现一些错误，而且使用的时候还会失去代码提示功能

如何向打包后的库里加入声明文件呢？ 其实很简单，只需要引入 vite-plugin-dts
`pnpm i vite-plugin-dts -D -w`
然后修改一下 vite.config.ts 引入这个插件

```ts
import { defineConfig } from "vite";
import vue from "@vitejs/plugin-vue"
import dts from 'vite-plugin-dts'

export default defineConfig(
    {
        build: {...},
        plugins: [
            vue(),
            dts({
                //指定使用的tsconfig.json为我们整个项目根目录下掉,如果不配置,你也可以在components下新建tsconfig.json
                tsConfigFilePath: '../../tsconfig.json'
            }),
            //因为这个插件默认打包到es下，我们想让lib目录下也生成声明文件需要再配置一个
            dts({
                outputDir:'lib',
                tsConfigFilePath: '../../tsconfig.json'
            })

        ]
    }
)
```

然后执行打包命令你就会发现你的 es 和 lib 下就有了声明文件

准备发布：
发布之前更改一下我们 components 下的 package.json 如下

```json
{
  "name": "@gyhyfj/vscale",
  "version": "1.0.0",
  "main": "lib/index.js",
  "module": "es/index.js",
  "scripts": {
    "build": "vite build"
  },
  "files": ["es", "lib"],
  "keywords": ["gyhyfj", "vue3组件库"],
  "author": "gyhyfj",
  "license": "MIT",
  "description": "",
  "typings": "lib/index.d.ts"
}
```

其中：
pkg.module 让构建工具优先使用我们的 module 入口（如果你的环境支持 ESModule）
pkg.files files 是指我们需要发布到 npm 上的目录，因为不可能 components 下的所有目录都被发布上去

## 发布

可以使用 glup 自动化打包发布 https://juejin.cn/post/7126493560190271525

手动的方式是：
网上很多教程，
需要注册 npm 账号，然后把 npm 源切换回官方的源
`pnpm publish --access public`

## 样式拆分打包

此时打包的结果，引入后回发现没有样式，需要全局引入 css 文件才行
而我们需要的组件库是每个 css 样式放在每个组件其对应目录下，这样就不需要每次都全量导入我们的 css 样式

处理 less 文件
首先我们需要做的是将 less 打包成 css 然后放到打包后对应的文件目录下
首先我们需要先安装一些工具 cpy 和 fast-glob `pnpm i cpy fast-glob -D -w`
在 components 下新建 build 文件夹（来存放我们的一些打包工具）,
在下面新建 buildLess.ts

```ts
import cpy from 'cpy'
import { resolve } from 'path'

const sourceDir = resolve(__dirname, '../src')
//lib文件
const targetLib = resolve(__dirname, '../lib')
//es文件
const targetEs = resolve(__dirname, '../es')
console.log(sourceDir)
const buildLess = async () => {
  await cpy(`${sourceDir}/**/*.less`, targetLib)
  await cpy(`${sourceDir}/**/*.less`, targetEs)
}
buildLess()
```

在 package.json 中新增命令` "build:less": "esno build/buildLess"`
终端执行 pnpm run build:less 你就会发现 lib 和 es 文件对应目录下就出现了 less 文件

但是：
我们最终要的并不是 less 文件而是 css 文件，所以我们要将 less 打包成 css，所以我们需要用到 less 模块`pnpm i --save-dev @types/less -D -w`
buildLess.ts 如下

```ts
import cpy from 'cpy'
import { resolve, dirname } from 'path'
import { promises as fs } from 'fs'
import less from 'less'
import glob from 'fast-glob'
const sourceDir = resolve(__dirname, '../src')
//lib文件目录
const targetLib = resolve(__dirname, '../lib')
//es文件目录
const targetEs = resolve(__dirname, '../es')

//src目录

const srcDir = resolve(__dirname, '../src')

const buildLess = async () => {
  //直接将less文件复制到打包后目录
  await cpy(`${sourceDir}/**/*.less`, targetLib)
  await cpy(`${sourceDir}/**/*.less`, targetEs)

  //获取打包后.less文件目录(lib和es一样)
  const lessFils = await glob('**/*.less', { cwd: srcDir, onlyFiles: true })

  //遍历含有less的目录
  for (let path in lessFils) {
    const filePath = `${srcDir}/${lessFils[path]}`
    //获取less文件字符串
    const lessCode = await fs.readFile(filePath, 'utf-8')
    //将less解析成css

    const code = await less.render(lessCode, {
      //指定src下对应less文件的文件夹为目录
      paths: [srcDir, dirname(filePath)],
    })

    //拿到.css后缀path
    const cssPath = lessFils[path].replace('.less', '.css')

    //将css写入对应目录
    await fs.writeFile(resolve(targetLib, cssPath), code.css)
    await fs.writeFile(resolve(targetEs, cssPath), code.css)
  }
}
buildLess()
```

执行打包命令之后你会发现对应文件夹下多了.css 文件

接下来：
现在我已经将 css 文件放入对应的目录下了，但是我们的相关组件并没有引入这个 css 文件；所以我们需要的是每个打包后组件的 index.js 中出现如：`import "xxx/xxx.css"`这样的语句，我们的 css 才会生效
所以：
我们需要对 vite.config.ts 进行相关配置：
首先我们先将.less 文件忽略`external: ['vue', /\.less/],`
这时候打包后的文件中如 button/index.js 就会出现`import "./style/index.less"`
然后我们再将打包后代码的.less 换成.css 就大功告成了

```ts
...
plugins: [
            ...

            {
                name: 'style',
                generateBundle(config, bundle) {
                    //这里可以获取打包后的文件目录以及代码code
                    const keys = Object.keys(bundle)

                    for (const key of keys) {
                        const bundler: any = bundle[key as any]
                        //rollup内置方法,将所有输出文件code中的.less换成.css,因为我们当时没有打包less文件

                        this.emitFile({
                            type: 'asset',
                            fileName: key,//文件名名不变
                            source: bundler.code.replace(/\.less/g, '.css')
                        })
                    }
                }
            }
        ...
        ]
...
```

最终的 vite.config.ts 如下：

```ts
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
import dts from 'vite-plugin-dts'

export default defineConfig({
  build: {
    target: 'modules',
    //打包文件目录
    outDir: 'es',
    //压缩
    minify: false,
    //css分离
    //cssCodeSplit: true,
    rollupOptions: {
      //忽略打包vue和.less文件
      external: ['vue', /\.less/],
      input: ['src/index.ts'],
      output: [
        {
          format: 'es',
          //不用打包成.es.js,这里我们想把它打包成.js
          entryFileNames: '[name].js',
          //让打包目录和我们目录对应
          preserveModules: true,
          //配置打包根目录
          dir: 'es',
          preserveModulesRoot: 'src',
        },
        {
          format: 'cjs',
          //不用打包成.mjs
          entryFileNames: '[name].js',
          //让打包目录和我们目录对应
          preserveModules: true,
          //配置打包根目录
          dir: 'lib',
          preserveModulesRoot: 'src',
        },
      ],
    },
    lib: {
      entry: './index.ts',
      formats: ['es', 'cjs'],
    },
  },

  plugins: [
    vue(),
    dts({
      //指定使用的tsconfig.json为我们整个项目根目录下掉,如果不配置,你也可以在components下新建tsconfig.json
      tsConfigFilePath: '../../tsconfig.json',
    }),
    //因为这个插件默认打包到es下，我们想让lib目录下也生成声明文件需要再配置一个
    dts({
      outputDir: 'lib',
      tsConfigFilePath: '../../tsconfig.json',
    }),

    {
      name: 'style',
      generateBundle(config, bundle) {
        //这里可以获取打包后的文件目录以及代码code
        const keys = Object.keys(bundle)

        for (const key of keys) {
          const bundler: any = bundle[key as any]
          //rollup内置方法,将所有输出文件code中的.less换成.css,因为我们当时没有打包less文件

          this.emitFile({
            type: 'asset',
            fileName: key, //文件名名不变
            source: bundler.code.replace(/\.less/g, '.css'),
          })
        }
      },
    },
  ],
})
```

最后我们将打包 less 与打包组件合成一个命令(package.json)：`"build": "vite build & esno build/buildLess"` （这里需要全局安装一个 esno）

后续直接执行 `pnpm run build` 即可完成所有打包
