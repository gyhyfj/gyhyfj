# 跨域问题

## 浏览器同源策略

请求时的 协议 域名 端口号，只有有一个不同，就会跨域

## jsonp

script 的 src 不受同源策略限制，可以跨域请求数据，但只能发送 get 请求
缺点是只能发送 get 请求，不安全且不容易维护

后端返回一个函数，这个函数是在前端定义的，后端把值注入到这个函数的参数中

::: code-group

```js [frontend]
const jsonp = name => {
  let script = document.createElement('script')
  script.src = 'http://localhost:3000/api/jsonp?callback=' + name
  document.body.appendChild(script)
  return new Promise(resolve => {
    window[name] = resolve // script 标签拿到返回的函数后调用它，并把后端返回的参数resolve出去
  })
}

jsonp(`callback${Date.now()}`).then(console.log) // 调用后即可拿到后端返回的数据
```

```js [backend]
import express from 'express'

const app = express()
app.get('/ai/jsonp', (req, res) => {
  const { callback } = req.query
  res.send(`${callback}('hello jsonp')`)
})

app.listen(3000, () => console.log('server is running'))
```

:::

## 前端代理

开发环境本地转发 如 vite 的 server - proxy 字段

## 后端设置允许跨域请求头

```js
res.setHeader('Access-Control-Allow-Origin', '*')

// 或
// res.setHeader('Access-Control-Allow-Origin','http://127.0.0.1:5500') 只针对5500端口
```

## 运维解决

nginx 配置代理
swa 配置请求头
