# 计算机网络

## 计算机网络体系结构

OSI 7 层体系结构

应用层
表示层
会话层
运输层
网络层
数据链路层
物理层

TCP/IP 4 层体系结构

应用层 HTTP SMTP DNS RTP 协议
运输层 TCP UDP 协议
网际层 IP 协议
网络接口层
（把物理层和数据链路层合并为网络接口层，会话层和表示层合并入应用层）

## HTTP 和 HTTPS 协议

1. HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL/TLS 协议进行了加密处理，相对更安全
2. HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP 是 80，HTTPS 是 443
3. HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
4. HTTPS 需要 SSL 证书，除免费的 SSL 证书外，功能越强大的证书费用越高

HTTPS 通信流程：TLS4 次握手：
客户端请求 https 链接，服务端返回证书（公钥），客户端产生一个随机秘钥，用公钥加密，返回给服务端，双方通过对称秘钥加密后的密文通信

## GET 和 POST

GET: 向服务器获取数据，POST：向服务器提交数据，通常会造成服务器资源的修改；区别为：
应用场景：
一般 Get 请求用于对服务器资源不会产生影响的场景，而 Post 请求一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作
是否缓存：
浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存
发送的报文格式：
Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。
参数传递方式：
GET 参数通过 URL 传递，POST 放在 Request body 中
安全性：
Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。
请求长度：
浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。（这个限制是特定的浏览器及服务器对它的限制，而非 HTTP 协议规范的限制）
参数类型：
get 的参数类型只接受 ASCII `[ˈæski]` 字符，post 的参数传递支持更多的数据类型。

## POST 和 PUT

POST 请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）

PUT 请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次 PUT 操作，其结果并没有不同。（可以理解为时更新数据）

## HTTP 请求报文

请求⾏（请求方法 url 协议版本） 请求头部 空⾏ 请求体（post put 等请求携带的数据）

## HTTP 响应报文

响应⾏（协议版本 状态码 状态码的原因短语） 响应头 空⾏ 响应体

## URL 组成

7 部分
协议部分 域名部分 端口部分（不写则默认为 80 或 443） 虚拟目录部分 文件名部分 参数部分 锚部分

## 当在浏览器中输入网址并且按下回车之后发生了什么

1. 解析 URL
2. 缓存判断
3. DNS 解析
4. 获取 MAC 地址（数据链路层的发送需要加入通信双方的 MAC 地址）
5. TCP 三次握手
6. HTTPS 握手（TLS4 次握手）
7. 返回数据
8. 页面渲染
9. TCP 四次挥手（TCP 断开连接）

## HTTP 状态码

1xx 接受的信息正在处理
2xx 请求正常处理完毕
3xx 301 302 303 307 重定向 304 让客户调用缓存
4xx 客户端错误，服务器无法处理请求
5xx 服务端错误，服务端处理请求出错

## TCP 三次握手四次挥手

ACK 应答；SYN 建立；FIN 终止

### 三次握手

三次握手（Three-way Handshake）其实就是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。
进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。

确认对方身份,为后续可靠性传输做准备以及确认对方接受和发送信息的能力

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。
第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。
第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。
第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

三次握手：客户端、服务端要确认各自的发送功能和接收功能是正常的

第一次握手：客户端发送网络包，服务端收到了，这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：服务端发包，客户端收到了，这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常

### 为什么不能是两次握手

如果是两次握手，发送端可以确定自己发送的信息和包能对方能收到，但对方无法确定自己发的包对方能收到。
并且两次握手的话, 客户端有可能因为网络阻塞等原因会发送多个请求报文，延时到达的请求又会与服务器建立连接，浪费掉许多服务器的资源。

### 四次挥手

刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求：

第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。

### 四次挥手的原因

因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个 ACK 报文，告诉客户端，“你发的 FIN 报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要四次挥手；
TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。

## WebSocket

WebSocket 是一种在单个 TCP 连接上进行全双工通信的协议。
WebSocket 是 HTML5 提供的一种浏览器与服务器进行全双工通讯的网络技术，基于 TCP 传输协议，并复用 HTTP 的握手通道。
浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。
WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：服务器和客户端都可以向对方主动推送消息。

特点：
全双工
没有同源限制，客户端可以与任意服务器通信
协议标识符是 ws 或 wss，默认端口也是 80 或 443

场景：
一切需要持续接收服务端信息，替代轮询的场景
实时聊天 协同合作 位置应用 弹幕 实时推送消息
