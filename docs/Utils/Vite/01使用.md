# Vite

在浏览器支持 ES 模块之前, JS 没有原生的机制让开发者以模块化方式开发, 因此就有了`打包`的概念: 使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件

然而随着应用体积的增大, 需要处理的 JS 代码量也呈指数级增长, 导致开发阶段冷启动和热更新速度下降

基于浏览器开始原生支持 ESM, 且越来越多的 JS 工具使用非 JS 语言编写, Vite 解决了上述的问题

## 冷启动

基于打包器的启动方式, 必须先抓取并构建整个应用, 然后才能提供服务

而 Vite 的做法是:

vite 先将应用中的模块区分为`依赖`和`源码`两类,
依赖大多数为开发时不会变的纯 JS 库等, 较大的依赖处理代价很高, 依赖也通常存在多种模块化格式
使用 esbuild 预构建依赖,
源码通常包含一些非 JS 的文件, 如果 JSX, css,vue 文件等, 时常会被编辑, 且并不是所有的源码都需要被同时加载

Vite 以原生 ESM 的方式提供源码, 模块之间的依赖关系的解析由浏览器实现, Vite 只需要在浏览器请求源码时进行按需转换和提供

## 热更新

基于打包器的启动方式, 重建整个包效率低下, 更新速度会随着应用体积增大而直线下降
优化的打包器支持了动态模块热替换 HMR, 允许一个模块热替换它自己, 而不影响页面其余部分, 但即使这样, 其热更新速度也会随着应用规模的增长而显著下降

而 Vite 的做法是:
HMR 在原生 ESM 上执行, 当编辑一个文件时, Vite 只需要精确地使被变价的模块与其最近的 HMR 边界之间的链失活 (大多数时候只是模块本身) , 使得无论应用大小如何, HMR 始终能保持快速更新
Vite 同时利用 HTTP 头来加速整个页面的重新加载, 源码模块的请求使用协商缓存, 依赖模块使用强缓存, 以减少请求次数

## 为什么生产环境仍需打包

在生产环境中发布未打包的 ESM 仍然效率低下
想要获取最佳加载性能, 还是需要对代码进行 tree-shaking、懒加载和 chunk 分割 (以减少初始加载时间、提高缓存命中率、并行加载)

## 为什么不用 ESBuild 打包

尽管 esbuild 速度更快, 但 Vite 采用了 Rollup 灵活的插件 API 和基础建设, 这对 Vite 在生态中的成功起到了重要作用
未来有可能使用 esbuild 进行生产构建

## 缺点

dev 环境因为不生成 bundle, 会导致大量的 http 请求
dev 环境下启动 dev server 后, 第一次加载页面会比较慢 (但之后会比较快, 因为完成转换的内容会被缓存)
dev 环境使用 esbuild, 正式打包时使用 rollup, 可能会出现一些功能在测试环境正常, 但构建后异常的现象 (比如 vue-i18n 9 以上版本的@直接使用会报错, 需要用{'@'}替代, 但 esbuild 开发中有时不报错, rollup 打包后会遇到项目整个挂掉) 但 esbuild 也在迅速改进, 将来有可能成为正式环境的打包工具
