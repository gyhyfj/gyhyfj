# SSR in Vue

vue 提供了一些实现 ssr 的 api , 如`renderToString ` 和`createSSRApp`
基于这些 api 的完整的实现会非常复杂,
如果没有丰富的 SSR 和构建工具经验, 且不需要对应用的架构做深入定制, 更应使用一种更通用的、更集成化的解决方案, 帮你抽象掉那些复杂的东西

## SSR 友好的代码

通常会有这些要求, 但具体实现会基于使用的框架

1. 为了更好的性能, 默认情况下响应性在 SSR 期间是禁用的。
2. 组件的一些生命周期钩子只会在客户端运行。只有 beforeCreate 和 created 这两个钩子会在 SSR 期间被调用, 应避免在这些生命周期中使用会产生副作用且需要被清理的代码, 如创建定时器
3. 通用代码不能访问平台特有的 API, 如浏览器特有的 window 对象等。通常的方法是在仅客户端特有的生命周期钩子中惰性地访问它们
4. 需要避免跨请求状态污染, 如在一个 JavaScript 模块的根作用域中声明共享的状态, 是一种单例模式, 在纯客户端运行时没有问题, 因为浏览器每次进行页面访问, 应用模块都会重新初始化。但在服务端渲染时, 应用模块只会在服务器启动时初始化一次, 同一个模块会在多个请求间被复用, 单个用户特定的数据可能会泄露给另一个用户的请求。虽然从理论上讲可以在每个请求上重新初始化所有 JS 模块, 就像在浏览器中那样, 但这种初始化操作成本很高, 会显著影响服务器性能。推荐的方法是在每个请求中为整个应用创建一个新的实例, 包括 router 和全局 store, 然后用应用级 provide 来提供共享状态, 而不是在组件中去将其导入
5. 避免激活不匹配, 如使用不符合规范的 html 结构, 比如 div 标签放在 p 标签中；如渲染的数据中包含随机生成的值；如服务端和客户端时区不一样导致代码在两边运行时, 时间的转换结果不一样
6. 自定义指令不做特殊处理会被 SSR 忽略
7. Teleport 组件需要特殊处理
